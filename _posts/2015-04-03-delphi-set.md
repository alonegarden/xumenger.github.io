---
layout: post
title: Delphi集合的用法
categories: delphi之基础语法 delphi之容器类
tags: delphi 集合
---


参考：[http://www.cnblogs.com/doit8791/archive/2012/08/17/2644859.html](http://www.cnblogs.com/doit8791/archive/2012/08/17/2644859.html)


集合是Pascal特有的数据类型，在Visual Basic、C/C++都没有（虽然C++ Builder提供了一种模板类成为集合，它模仿了Pascal集合的行为）。集合用一种有效的手段来表示一组有序数、字符和枚举值。声明一个集合用用关键字 set of，并在其后面跟上有序类型或一个集合可能值得所有有限子集。示例如下

    type
        TCharSet = set of char;    //可能的值是 #0至#255
        TEnum = (Monday, Tuesday, Wednesday, Thursday, Friday);
        TEnumSet = set of TEnum;    //包含了TEnum值得任何组合
        TSubrangeset = set of 1..10;    //可能的值：1~10
        TAlphaSet = set of 'A'..'Z';    //可能的值：'A'、'B'...'Z'

注意，一个集合最多只能有255个元素。另外，只有有序的类型才能跟关键字set of ，因此下面的代码是非法的

    type 
        TIntSet = set of Integer;    //非法，太多的元素
        TStrSet = set of String;     //非法，不是有序的类型

集合在内部以位的形式存储它的元素，这使得在速度和内存利用上都更有效。集合如果少于32个元素，它就存储在 CPU 的寄存器中，这样的效率就更高了，为了用集合类型得到更高的效率。记住，集合的基本类型的元素数目要小于32。

 
## 一、使用集合

当使用集合的元素的时候，使用方括号。下面代码表明如何使用集合类型的变量并给它赋值

### 1.直接在所在过程中var中定义

    var    
        SubrangeSet : set of 1..10;    //可能是1到10的任意数
    begin 
        SunrangeSet := [1,2,4..6];
    end;

### 2.在type中定义

    type
        TcharSet = set of char;
    var
        CharSet : TCharSet;
    begin
        CharSet :=['A'..'J','a','m'];
    end;


## 二、集合的值

1. 集合的值放在一对方括号里，中间各元素使用逗号隔开。如：[1,2,5]和['a', 'e', 'i']都是集合
2. 在集合中可以没有任何元素，这样的集合称为空集。[]空集
3. 在集合中，如果元素的值是连续的，则可用子届型的表示法表示。例如：[1,2,3,4,5,6,10,15] 可以表示成[1..5,10,15]
4. 集合的值与方括号内元素出现的次序无关。例如[1,5,8]和[1,8,5]的值相等
5. 在集合中同一个元素的重复出现对集合的值没有影响。例如[1,8,5,1,8]与[1,5,8]的值相等
6. 每个元素可用基类型所允许的表达式来表达。如[1,1+1,4]、[succ(ch)]


## 三、集合的运算

集合类型变量不能进行算术运算，因为集合是无序的，不能使用ord、pred、succ等函数

### 1.赋值运算

只能通过赋值语句给集合变量赋值，不能通过读语句赋值，也不能通过写语句直接输出集合变量的值。如：

    集合变量赋值：c:=['2']; i:=[5]; w:=[];
    集合变量赋子界值：c:=['a'..'z']; i:=[1..7];
    集合变量赋枚举值：c:=['a','b','d','m'm]; i:=[1,2,4,5];

### 2.集合的并、交、差运算

可以对集合进行并（+）、交（*）、差（-）三种运算，每种运算只有一个运算符、两个运算对象，结果仍然为集合。之一它们与算术运算的区别

#### 1)并运算（关系代数运算符∪）

A、B为两个集合，由集合A中的元素加上B中的与A不重复的所有元素组成的集合，成为集合A和B的并。即A+B，如

    [X，Y，Z]+[X] 为 [X，Y，Z] { 两个集合中不重复的所有元素 }
    [1]+[4] 为[1，4]

用+、-运算符或者Include()和Exclude()过程，能对一个集合变量增删元素：

    Include(CharSet, 'a');    //在集合中增加元素'a'
    CharSet := CharSet+['b'];    //在集合中增加元素'b'
    Exclude(CharSet, 'x');    //在集合中删除元素'x'    
    CharSet := CharSet-['y', 'z'];    //在集合中删除元素'y'， 'z'

提示：尽可能地用Include()和Exclude()来增删元素，尽可能少用+、-运算符。因为Include()和Exclude()仅需要一条机器指令，而+和-需要13+6n（n是集合的按位的长度）条机器指令

#### 2) 交运算 （关系代数运算符∩）

A、B为两个集合，由既属于集合A又属于集合B中的所有元素组成的集合，称为集合A和B的交。也就是A*B，如：

    [X，Y，Z]*[X] 为 [X] { 两个集合中的相同元素 }
    [X，Y，Z]* 为 []

#### 3)差运算（关系代数运算符-）

A、B为两个集合，由集合A中的元素除去集合B中与A相同的元素组成的元素，称为集合A和B的差，即A-B，如

    [X，Y，Z]-[X] 为 [Y，Z ] { 在集合A中又不在集合B中的所有元素 }
    [X，Y，Z]- 为 [X，Y，Z]

 
### 3.集合的关系运算：运算结果是布尔值

关系运算符：

* =相等
* <>不相等
* >=包含，表示前者包含后者　　
* <=包含于，表示前者包含于后者

例如：[a,b,c]=[b,c,a] 为true，元素个数相同，内容相同，不管排列顺序如何。 [a,b,c]>=[a] 为true；[a,b]<=[a,b,c] 为true。

in运算：in的右边为集合，左边为与集合基类型相同的表达式，为布尔型。in测试的是一个元素是否在集合中。相当于集合论中的∈。它们都是二目运算，且前４个运算符的运算对象都是相容的集合类型。例如：a in［b,c］ 为false。

CharSet中是否有字母'S':

    if 'S' in CharSet then
    //继续运行

下面的代码判断在EnumSet中是否没有Monday :

    if not (Monday in EnumSet) then
    //继续运行

设集合a:=[1..10]； x 为integer，如x在集合a中即删除a中的元素x，否则把元素x添加到集合a中。程序段如下： if x in a then a:=a-[x] else a:=a+[x]

集合没有的直接运算：集合中元素的个数以及打印输出集合中每个元素。

