---
layout: post
title: 总结一下最近开发遇到的问题，以及最近需要学习的知识点
categories: 学习计划 开发总结 delphi之异常处理
tags: 学习 计划 总结
---

最近在工作中开发任务、被提缺陷等等，让我遇到了各种各样的问题

* 有的是一些简单的细节问题，但是因为不小心、没注意，结果这些看似很小的问题点导致了很严重的问题
* 有的是比较有技术含量的问题

这里做一个整理，记录一下遇到的问题，记录一下自己的思考和总结。

不得不考虑到自己当前的思考和总结中会存在错误、偏差、不全面的情况，但是还是有比较进行简单的整理，日后发现有理解不对的可以即时修改、完善。

# 细节但影响极大的问题

## Delphi结合C++编程时的stdcall关键字

有这样的开发场景：使用C++封装了发送信息和接收确认信息的功能，然后以dll形式导出，Delphi端加载dll中的发送信息的API、并且在Delphi端实现回调函数并注册到C++端，回调函数在C++端当收到确认信息的时候被C++端调用。

开发的时候因为不细心没有在一些回调函数和导出函数的定义中使用关键字`stdcall`导致C++和Delphi的不兼容，比如当C++端收到确认信息并调用回调函数将确认信息传给Delphi端的时候，因为没有使用`stdcall`导致传过来的信息是乱码，为什么呢？因为没有使用stdcall规定函数参数的出栈顺序，从而出现C++和Delphi端的不一致。

关于stdcall的比较详细的介绍可以参见[cdecl、stdcall、fastcall函数调用约定区别](http://blog.csdn.net/fly2k5/article/details/544112)。

## Delphi结合C++编程时变量的生命周期

#### 犯错的情景：

C++端调用回调函数将确认信息传给Delphi端，Delphi端直接将确认信息Push到队列，但是后面弹出队列的时候出现内存错误。

#### 原因说明：

C++端调用Delphi注册的回调函数将确认信息传给Delphi端，但是当C++端的调用回调函数的函数执行完之后便要释放在C++端的存储确认信息的内存。

* 可能是C++端直接声明的一个结构体变量（在栈内存上），在C++端的调用回调函数的函数执行完之后就自动将该变量的内存释放了
* 也可能是C++端在堆内存上申请一块内存，然后将一个确认信息结构体的指针指向它，但是在函数执行完之后也要显式地进行释放

如上面描述的C++端在调用回调函数将确认信息传给Delphi之后就将C++端存储确认信息的内存释放了，显然Delphi这边直接在回调函数中将确认信息Push到队列中，等到再将信息Pop出来的时候，其实在C++端已经将那块内存释放了，所以当然会出现内存错误。

#### 解决方法：

C++端自己独立申请内存（无论是在堆上还是在栈上），然后调用Delphi端注册的回调函数传给Delphi，然后C++端释放那块内存。

所以Delphi端的回调函数的实现就应该自己先申请一块内存，将C++端传过来的数据拷贝到自己申请的内存中，在存入队列，最后C++端释放了那块内存，但是因为Delphi自己申请了内存并将相关数据完整拷贝过来，所以就显然不会出现之前出现的内存访问错误的问题。

## 网络编程的一个技巧

就如上面描述的Delphi的回调函数中接收确认信息的场景，正确的处理方式是这样的。

* 先申请内存，拷贝接收到的信息
* 然后将这块内存的指针Push到队列中

就只需要做这两件事情即可。

具体的对数据的处理，专门开一个或多个线程进行处理，线程专门从队列中Pop出信息进行处理。

因为假如直接在回调函数中接收确认信息并进行处理，那么可能造成回调函数的处理时间太长，紧接着来的其他的确认信息得不到保存和处理，因此出现网络阻塞的问题。

所以回调函数只需要做最简单的事情：申请内存，向队列中Push数据。这样就能快速的在回调函数中处理每个确认信息，尽快的处理紧接着在后面的其他确认信息。而具体的处理由专门的线程从队列中Pop出数据再专门处理。

# 比较深入的技术

## 数据库知识

最近开发中遇到了关于数据库死锁的问题，但是自己这方面的知识完全是不系统、不深入。

对于数据库，不光是锁、死锁的知识，还有更多的知识，比如SQL优化、事务、索引、高并发等很多深入的技术点还亟待专门钻研。

## 异常处理

在进行一个项目开发中，异常处理是很重要的，规范的、全面的异常处理可以保证项目的稳定性，但是目前自己在开发中总是可能会忽略一些点，还是不能进行很全面的异常处理、考虑各种异常情况，另外对于Delphi的三种异常处理的结构还是没有完全缕清楚

* try....except..(except里面处理异常)..end
* try....except..(except里再抛出异常)..end
* try....finally....end

## 各种复杂情景下的内存管理

内存管理说起来很简单，无非就是先申请内存-->接着使用申请的内存-->最后在使用完内存之后一定要释放。

但是在具体的开发情境中，在有几千几万行的项目中，还真不敢保证能精确的把上面这三步做到。

有很多中复杂的情况，出现的看似偶然但是严重的问题可能令你招架不住

* 内存泄露
* 内存碎片
* out of memory
* 等等各种内存的问题

可以参考以下关于内存管理的文章

* [《C++拷贝构造函数（深拷贝、浅拷贝）》](http://www.xumenger.com/cpp-class-copy-20151112/)
* [《Delphi使用FillChar时候如果有string可能导致内存泄漏》](http://www.xumenger.com/delphi-string-memory-20151118/)
* [《内存的分配与释放，内存泄漏》](http://www.xumenger.com/memory-allocation-deallocation/)中所说的很多种可能的内存泄露问题
* 还有很多很多中极其具体的、细节的情景
