---
layout: post
title: Delphi各种数值类型的取值范围
categories:  delphi之基础语法 
tags: delphi 整数 浮点数 整数溢出 字符串
---

## 整数

|    类型    |    范围    |    字节    |    备注    | 
| ---------- | ---------- | ---------- | ---------- |
|  Integer   |  -2147483648 .. 2147483647  |  4  |  有符号32位  |
|  Cardinal   |  0 .. 4294967295  |  4  |  无符号32位  |
|  Shortint  |  -128 .. 127  |  1  |  有符号8位  |
|  Smallint  |  -32768 .. 32767  |  2  |  有符号16位  |
|  Longint  |  -2147483648 .. 2147483647  |  4  |  有符号32位  |
|  Int64  |  -2^63 .. 2^63-1  |  8  |  有符号64位  |
|  Byte  |  0-255  |  1  |  无符号8位  |
|  Word  |  0 .. 65535  |  2  |  无符号16位  |
|  Longword  |  0 .. 4294967295  |  4  |  无符号32位  |

我们在使用这些数据类型的时候，需要考虑它们的范围，如果超出了其范围会导致一些很严重的错误，常见的错误有

* 字符串转换成整型出现错误
* 整数溢出，比如Integer转成Byte时，如果超出会将多余的截断，导致出错！

### 字符串转成整型时可能出错

```
var
  i: Integer;
begin
  i:= StrToInt('2147483647');		
  {字符串转成整型的时候，因为这个字符串对应的整数在Integer的范围内，所以可以转换成功，转换后的i的值是2147483647}

  i:= StrToInt('2147483648');
  {这时候因为字符串对应的整数超出Integer的范围，所以在这里转换会抛出异常：''2147483648' is not a valid integer value'}

  i:= StrToIntDef('2147483648', 0);
  {StrToIntDef函数的作用是如果在转换字符串时有异常，那么将后面的那个默认值作为返回值
  	常见的异常有，比如这里的超出整数范围的异常；还有这样的异常，比如StrToInt('ss')，字符串包含除数字之外的其他字符也会有异常}

  i := 2147483647 + 1;
  {因为Integer的最大值是2147483647，加1就超出了范围，我在Delphi 6 上对这段代码是编译不过去的}

  i := StrToInt('2147483647') + 1;
  {这里面因为没有直接用2147483647 + 1，而是先将字符串转成2147483647再加一，所以编译器在编译时没法检查出来，所以可以编译通过
  	因为Integer的最大值就是2147483647，现在对其加一，超出范围，就出现了“整数溢出”
  	但是比较要命的是，这种情况下不会抛出异常，实际执行这段代码后i的值会变为 -2147483648}

end;
```

### 高精度整数转成低精度整数导致被截断

```
var
  b: Byte;      //0-255 无符号8位
  i: Integer;   //-2147483648 .. 2147483647 有符号32位
  c: Cardinal;  //0 .. 4294967295 无符号32位
begin
  //b := 333;   如果这样写，因为333超过Byte的最大范围，直接编译不过！
  
//过大的Integer转成Byte导致精度丢失
  i := 333;     //对应二进制：101001101
  b := Byte(i); //上面可以看出i是9位的二进制，而Byte是8位的，所以会被截断
                //这里Integer强转成Byte时，9位会丢失一位，变成：01001101
                //强转类型后，b的值是77，对应二进制：01001101

//同理，当Cardinal强转成Integer时
//因为Cardinal是32位无符号，Integer是32位有符号
//Cardinal的正数部分超过Integer的正数部分
//如果Cardinal类型大于2147483647的值强制转成Integer，也会导致被截断而出现意想不到的错误！！！

end;
```

## 浮点数

|    类型    |    范围    |    字节    |    备注    | 
| ---------- | ---------- | ---------- | ---------- | 
|  Real  |  5.0×10^-324 .. 1.7×10^308  |  8  |  [精度]15..16  |
|  Real48  |  2.9×10^\-39 .. 1.7×10^38  |  6  |  [精度]11..12，向后兼容  |
|  Single  |  1.5×10^\-45 .. 3.4×10^38  |  4  |  [精度]7..8  |
|  Double  |  5.0×10^\-324 .. 1.7×10^308  |  8  |  [精度]15..16  |
|  Extended  |  3.6×10^\-4951 .. 1.1×10^4932  |  10  |  [精度]19..20  |
|  Currency  |  -922337203685477.5808 .. 922337203685477.5807  |  8  |  [精度]19..20  |

可以对应[《Delphi的Format函数在格式化Double类型时候的注意事项》](http://www.xumenger.com/delphi-format-20160308/)先去初步了解浮点数的使用

浮点数背后是涉及到计算机原理层面的知识的，所以不光要会用，更要在后期深入研究计算机原理层面的知识
