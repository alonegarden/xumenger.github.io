---
layout: post
title: x86汇编语言语法简介
categories: 深入学习之操作系统 深入学习之编译原理  
tags: 操作系统 进程 CPU 汇编语言 寄存器
---

## 说明

汇编语言的知识远不止于此

## 寄存器

任何程序在执行的过程中，都是存放在存储器里的指令序列执行的结果

寄存器用来存放程序运行过程中的各种信息，包括操作数地址、操作数以及运算的中间结果等

寄存器是CPU内部的高速存储单元，访问速度比内存快得多，当然价格也高得多

常用的寄存器分为四类：8个通用寄存器、6个段寄存器、1个标志寄存器、1个指令寄存器

**通用寄存器**

通用寄存器(8个)主要用于各种运算和数据的传送，每个寄存器都可以作为一个32位、16位或者8位来使用

EAX寄存器可以存储32位的数据。EAX的低16位可以表示为AX，可以存储16位的数据。AX寄存器又可以分为AH和AL两个8位的寄存器，AH对应AX寄存器的高8位，AL对应AX寄存器的低8位。只有数据存储寄存器可以按照上面所描述的方法进行使用。数据存储寄存器有EAX、EBX、ECX和EDX这4个

指针变址寄存器ESI可以按照32位或16位进行使用。同时，只可以将其分为32或16位进行使用

ESI寄存器可以存储32位的指针，其中低16位可以表示为SI，存储16位的指针，但无法像AX那样能拆分成高8位和低8位

|   32位      |      16位     |       高8位   |      低8位  |
| ------------| ------------- | ------------- | ------------|
|   EAX       |     AX        |     AH        |     AL      |
|   EBX       |     BX        |     BH        |     BL      |
|   ECX       |     CX        |     CH        |     CL      |
|   EDX       |     DX        |     DH        |     DL      |
|   ESI       |     SI        |               |             |
|   EDI       |     DI        |               |             |
|   EBP       |     BP        |               |             |
|   ESP       |     SP        |               |             |

通用寄存器中部分寄存器有特殊用途：

* EAX在乘法和除法指令中被自动使用
* CPU自动使用ECX作为循环计数器
* ESP寻址堆栈(更准确的叫栈)上的数据，ESP寄存器一般不参与算数运算，称为栈指针寄存器
* ESI和EDI通常用于内存数据的高速传送，称为源指针寄存器和目的指针寄存器
* EBP由高级语言用来引用参数和局部变量，称为栈帧基址指针寄存器

**指令指针寄存器**

指令指针寄存器(1个)EIP是一个32位的寄存器。在16位的环境中，其名称为IP

EIP寄存器通常保存着下一条要执行的指令的地址。下一条指令的地址为当前指令的地址加当前指令的长度

特殊情况是当前指令为一条转移指令，比如JMP、JE、LOOP等指令，会改变EIP的值，导致CPU执行指令产生跳跃性执行，从而构成分支与循环的程序结构

EIP中的值始终在引导CPU的执行

**段寄存器**

段寄存器(6个)被用于存放段的基地址，段是一块预分配的内存区域。有些段存放有程序的指令，有些则存放有程序的变量，另外还有其他的段，如堆栈段存放着函数变量和函数参数等

在16位CPU中，段寄存器只有4个，分别是CS(代码段)、DS(数据段)、SS(堆栈段)、ES(附加段)

在32位CPU中，段寄存器从4个扩展到6个，分别是CS、DS、SS、ES、FS和GS。FS和GS段寄存器也属于附加的段寄存器

注意：32位CPU的保护模式下，段寄存器的使用概念完全不同于16位CPU！

**标志寄存器**

在16位CPU中，标志寄存器称为FLAGS(有的也称为PSW，即程序状态字寄存器)。在32位CPU中，标志寄存器也随之扩展为32位，被称为EFLAGS

关于标志寄存器，16位CPU的标志已经满足日常的程序设计所用，这里主要介绍16位CPU中的标志

| 15 | 14 | 13 | 12 | 11 | 10 | 9  |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
|    |    |    |    | OF | DF | IF | TF | SF | ZF |    | AF |    | PF |    | CF |
|    |    |    |    |溢出 |方向| 中断| 陷阱|符号| 零  |    |辅助进位| | 奇偶|   | 进位|

标志寄存器中的每个标志位只占1位，而16位的标志寄存器并没有全部使用。16位的标志寄存器分为两部分，分别是条件标志和控制标志

条件标志寄存器说明：

* OF (Overflow Flag)：溢出标志，溢出时为1，否则位0
* SF (Sign Flag)：符号标志，运算结果为负时为１，否则为0
* ZF (Zero Flag)：零标志，运算结果为0时为1，否则为0
* AF (Auxiliary carry Flag)：辅助标志位，记录运算时第3位(半字节)产生的进位，有进位时为1，否则为0
* PF (Parity Flag)：奇偶标志，结果操作数中1的个数为偶数时为1，否则为0
* CF (Carry Flag)：进位标志，产生进位时为1，否则为0

控制标志寄存器说明：

* DF (Direction Flag)：方向标志，在串处理指令中用于控制方向
* IF (Interrupt Flag)：中断标志
* TF (Trap Flag)：陷阱标志

在平时的使用过程中，较为常用的标志有CF、PF、ZF、SF、DF和OF

16位CPU中的标志在32位CPU中继续使用，32位扩展了4个新的标志位

## 数据传送指令集

数据传送指令集常用的有5条，分别是push、pop、mov、xchg和lea

x86汇编语言，Windows上和Linux上有些不同，x86汇编有两种汇编语法：

* Intel语法
	* 先是目标，然后是源，也就是从右到左赋值，`mov dst, src`
	* Windows上流行
* AT&T语法
	* 先是源，然后是目标，也就是从左到右赋值，`mov src, dst`
	* Unix和Linux上流行

**mov指令**

mov指令是最常见的数据传送指令，类似于高级语言的赋值语句，该指令有两个参数，分别是源操作数(src)和目的操作数(dst)。其使用格式是： mov dst, src

mov指令可以实现寄存器与寄存器之间、寄存器与内存之间、寄存器与立即数、内存与立即数的数据传递。需要注意的是，内存与内存之间无法直接传递数据、目的操作数不能为立即数

mov指令的用法实例有：

```
mov eax, 12345678h              //寄存器<--立即数
mov eax, [00401000h]            //寄存器<--内存
mov eax, ebx                    //寄存器<--寄存器
mov [00401000h], 12345678h      //内存<--立即数
mov [00401000h], eax            //内存<--寄存器
```

**xchg指令**

xchg指令的功能是交换两个操作数的数据该指令有两个参数，分别是源操作数(src)和目的操作数(dst)。其使用格式是： xchg dst, src

xchg指令的用法实例如下：

```
xchg eax, ebx               //交换eax寄存器和ebx寄存器的值
xchg [00401000h], eax       //将00401000h所在内存地址的数据和eax寄存器的值交换
xchg eax, [00401000h]       //
```

**pop和push指令**

push和pop指令互为相反的操作指令。push指令的功能是将操作数压入堆栈，pop指令是将堆栈顶的操作数弹出，语法格式分别为：push 操作数；pop 操作数

```
push eax
pop eax

push 12345678h
pop eax

push [00401234h]
pop [00401234h]
```

push指令把一个32位的操作数送入堆栈，该操作数致使esp寄存器的值减4。esp寄存器始终指向栈顶。堆栈的方向是由高地址向低地址进行延伸，也就是执行的push次数越多，esp寄存器指向的地址越小。在32位平台上，每执行一次push指令，esp指向的地址都减小4字节

pop指令把esp指向地址(栈顶)中的值从如寄存器或内存中，然后esp指向的地址加4字节。执行的pop指令越多，esp寄存器指向的地址越大

**lea指令**

lea指令，即装入有效地址的意思。它的操作数就是地址，而不是具体的数据。这就是lea指令与mov指令的区别。其语法格式如下：lea dst, src

```
lea edi, [ebp + 0000000ch]
```

## 算数运算指令

**add指令**

add指令是加法指令，将源操作数和目的操作数相加，结果存储在目的操作数中。操作数的长度必须相同。语法格式：add dst, src

```
add eax, ebx
add ecx, 1
add [00402000h], edx
```

**sub指令**

sub指令是减法指令，将目的操作数和源操作数相减，结果存储在目的操作数中。操作数的长度必须相同。语法格式：sub dst, src

```
sub eax, ebx
sub ecx, 1
sub [00402000h], edx
```

**adc指令**

adc指令是带进位的加法，类似于add指令，区别在于将目的操作数与源操作数相加后，需要再加上CF中的值

执行adc后的结果为：目的操作数=目的操作数+源操作数+CF中的值。语法格式：adc dst, src

```
adc eax, ebx
adc ecx, 1
adc [00402000h], edx
```

**sbb指令**

sbb指令是带进位的减法，类似于sub指令，区别在于将目的操作数与源操作数相加后，需要再减去CF中的值

执行adc后的结果为：目的操作数=目的操作数-源操作数-CF中的值。语法格式：sbb dst, src

```
sbb eax, ebx
sbb ecx, 1
sbb [00402000h], edx
```

**inc指令**

加一指令，用于给操作数进行加一操作，语法格式：inc dst

```
inc eax
inc dword ptr [00402000h]
```

从功能上讲，inc eax指令与add eax, 1指令相同，但是inc的机器码更短，执行速度更快

**dec指令**

减一指令，用于给操作数进行减一操作，语法格式：dec dst

```
dec eax
dec dword ptr [00402000h]
```

在操作内存时，如果无法明确内存长度，必须明确指出需要操作内存的长度。dword ptr表示操作的内存是4字节的长度，word ptr表示操作的内存是2字节的长度，byte ptr表示操作的内存是1字节的长度

## 位运算指令

**and指令**

逻辑按位与运算指令，用于将目的操作数中的每个数据位与源操作数中的对应位进行逻辑与操作。语法格式为：and dst, src

该指令影响的标志位有OF、SF、ZF、PF和CF

**or指令**

逻辑按位或运算指令，用于将目的操作数中的每个数据位与源操作数中的对应位进行逻辑或操作。语法格式为：or dst, src

该指令影响的标志位有OF、SF、ZF、PF和CF

**not指令**

求反指令，通过将操作数的各位变反执行逻辑非操作。语法格式如下：not dst

```
not eax
```

**xor指令**

按位异或指令，将源操作数的每位与目的操作数的对应位进行异或操作。只有当原始操作数的数据与目的操作数的对应位不同时，结果才是1。语法格式为：xor dst, src

该指令影响的标志位有OF、SF、ZF、PF和CF

**test指令**

测试指令，测试目的操作数的单个位。该指令执行逻辑与操作，影响标志位，但不改变目的操作数的内容。语法格式：test dst, src

该指令影响的标志位有OF、SF、ZF、PF和CF

## 流程控制指令

**cmp指令**

比较指令，比较目的操作数和源操作数，隐含执行（相应设置标志位，但不改变目的操作数）从目的操作数中减掉源操作数的减法操作。语法格式：cmp dst, src

该指令影响的标志位有OF、SF、ZF、PF和CF

**jmp指令**

无条件跳转指令，会无条件跳转到标号指定处，语法格式：jmp 跳转目标

```
jmp eax
jmp target
```

**jcc指令**

代表条件跳转指令。注意是代表，而不是具体的指令。jcc指令是一个指令集合，包括：

|   转移类别   |   标志位     |       含义   | 
| ------------| ----------- | ------------- |
|   JO        |    OF=1     |     溢出      |
|   JNO       |    OF=0     |     无溢出    |
| JB/JC/JNAE  |    CF=1     | 低于/进位/不高于等于 |
| JAE/JNB/JNC |    CF=0     | 高于等于/不低于/无进位 |
|   JE/JZ     |    ZF=1     | 相等/等于0  |
|   JNE/JNZ   |    ZF=0     | 不相等/不等于0  |
|  JBE/JNA    |  CF=1或ZF=1 | 低于等于/不高于  |
|   JA/JNBE   |  CF=0或ZF=0 | 高于/不低于等于  |
|   JS        |    SF=1     | 符号为负　　 |
|   JNS       |    SF=0     | 符号为正 　　 |
|   JP/JPE    |    PF=1     |  '1'的个数为偶     |
|   JNP/JPO   |    PF=0     | '1'的个数为奇  |
|   JL/JNGE   |   SF<>OF    |  小于/不大于等于 |
|   JGE/JNL   |   SF=OF     |  大于等于/不小于  |
|   JLE/JNG   | ZF<>OF或ZF=1 |  小于等于/不大于 |
|  JG/JNLE    | SF=OF且ZF=0  | 大于/不小于等于 |

条件跳转指令根据标志位决定如何进行跳转，这些指令并不是所有的都会经常被用到，因此只要在写程序的时候留意和掌握经常使用的即可

**loop指令**

循环控制指令，需要ecx寄存器来进行计数，当执行到loop指令时，先将ecx寄存器中的值减一，如果ecx大于0，则跳转到loop指令后的标号处。语法格式：loop 目标地址

**call指令**

过程调用指令，其执行过程是先将下一条指令的地址压入堆栈，并将控制转移到目的地址

call指令相当于执行了 push eip 和 jmp目的地址 两条指令。语法格式：call 目标地址

**ret指令**

过程返回指令。该指令从堆栈上弹出返回地址，相当于执行了 pop eip 功能的指令。语法格式：ret

jmp、loop、call和ret指令都是通过改变eip寄存器来改变程序的执行流程的。但是切记一点：eip寄存器是无法通过指令进行明确操作的，如 add eip, 1等之类的指令。只有通过流程控制指令来改变eip寄存器的值

## 寻址方式

在程序执行的过程中，CPU会不断处理数据，而CPU处理的数据通常来自于3个地方

* 数据在指令中直接给出
* 数据在寄存器中
* 数据在内存中

而在编写汇编程序时，指令操作的数据来自于何处，CPU应该从哪里取得数据，是一个较为关键的问题。而CPU寻找最终要操作的数据的过程被称为“寻址”

**指令中给出的数据**

操作数直接放在指令中，作为指令的一部分存放在代码中，这种方式称为立即数寻址。这是惟一一种在指令中给出数据的方式

```
mov eax, 12345678h
```

**数据在寄存器中**

操作数在寄存器中存放，在指令中指定寄存器名称即可，这种方式称为寄存器寻址方式。这是惟一一种数据在寄存器中给出的方式

```
mov eax, ecx
```

**数据在内存中**

数据在内存中存放可以由多种方式给出，包括

* 直接寻址方式
  * 在指令中直接给出操作数所在的内存地址
  * 比如：mov eax, [00401234h]
* 寄存器间接寻址方式
  * 操作数的地址由寄存器给出，这里的地址指内存地址
  * 实际的操作数在内存中存储
  * 比如：mov eax, [eax]
* 其他寻址方式
  * 除了立即寻址和寄存器寻址外，其余的寻址方式所寻找的操作数均在内存中
  * 还有寄存器相对寻址、寄存器间接寻址、变址寻址、基址变址寻址、比例因子寻址等
