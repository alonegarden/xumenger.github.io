---
layout: post
title: Python2并发控制
categories: python之多线程 python之多进程
tags: python2 python3 python 爬虫 GIL CPU 锁 并发 进程 线程
---

[《Python2系列基础语法》](http://www.xumenger.com/python2-20170204/)是讲到了最简单的如何创建和启动多线程、多进程，但在并发编程时远不止这些，在实际的并发编程中需要考虑多线程/多进程之间的通信，需要考虑并发情况下数据的安全性。这里统一进行一个总结

同样的，正如[《Python2系列基础语法》](http://www.xumenger.com/python2-20170204/)一文中无法将Python2的多线程、多进程的更多的底层原理、更多形式的语法一一列举，这里也无法做到将所有的线程/进程间通信、并发控制的语法一一讲解，重点列举一些常用的

##线程间通信

Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO的Queue、LIFO的LifoQueue、优先级队列PriorotyQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用Queue实现线程间的同步

下面给一个简单的生产者消费者模型展示Queue在多线程环境下的应用

```
# -*- coding: utf-8 -*-

import threading
import Queue

# class Queue.Queue(maxsize=0)  maxsize指定Queue中数据的上限
# 一旦达到上限，插入就会导致阻塞；0表示没有上限
q = Queue.Queue()

def get():
    while True:
        try:
            print q.get(False)
        # 当队列为空时继续get，会导致抛出Empty异常，这里捕获异常判读队列是否为空
        except Queue.Empty, e:
            break

def put(id):
    for i in range(5):
        q.put('测试: ' + str(id * i))

if __name__ == '__main__':
    # 创建3个往队列中写数据的线程
    for i in range(3):
        thread = threading.Thread(target = put, args = (i,))
        thread.start()
    # 创建5个从队列中取出数据的线程
    for i in range(5):
        thread = threading.Thread(target = get)
        thread.start()

```

运行效果如下

![image](../media/image/2017-02-05/01.png)

注意，上面的get()方法中通过判断是否触发Queue.Empty异常来判断是否队列为空，因为多个线程都通过Queue.empty()来判断队列是否为空并不准确。所以这里通过异常的方式来处理，而不是通过Queue.empty()来判断

建议将get()方法修改为，多运行几次的话，其中就会有几次出现Queue.Empty异常的情况

另外关于Queue的更多的API如下：

* Queue.qsize() 返回队列的大小  
* Queue.empty() 如果队列为空，返回True,反之False  
* Queue.full() 如果队列满了，返回True,反之False 
* Queue.full 与 maxsize 大小对应  
* Queue.get([block[, timeout]]) 获取队列，timeout等待时间  
* Queue.get_nowait() 相当Queue.get(False) 
* Queue.put(item) 写入队列，timeout等待时间  
* Queue.put_nowait(item) 相当Queue.put(item, False) 
* Queue.task_done() 在完成一项工作之后，Queue.task_done() 函数向任务已经完成的队列发送一个信号 
* Queue.join() 实际上意味着等到队列为空，再执行别的操作

##进程间通信



##并发安全

上面讲到的Queue模块本身就是线程安全的，所以可以不需要再使用其他的额外的方法来实现线程安全
