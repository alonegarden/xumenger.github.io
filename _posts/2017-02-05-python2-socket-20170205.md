---
layout: post
title: Python2异步和事件驱动
categories: python之网络编程 python之多线程 python之多进程
tags: python2 python3 python 进程 线程 网络 网络编程 select socket Unix 事件驱动
---

事件驱动编程会一次监听不同的事件，对于组织程序流程是一个很好的解决方案，并不需要使用多线程的方法

考虑到这样一个程序，它想要监听一个套接字的连接，并处理收到的连接。有以下三种方式可以解决这个问题：

* 每次有新连接建立时就创建(fork)一个新进程，可以使用multiprocessing模块
* 每次有新连接建立时创建一个新线程，可以使用threading模块
* 将这个新连接加入到事件循环(event loop)中，并在事件发生时对其做响应

众所周知的是，使用事件驱动方法对于监听数百个事件源的场景的效果要好于为每个事件创建一个线程的方式。这并不意味着两者互不兼容，这只是表明可以通过事件驱动机制摆脱多线程

##事件驱动机制

事件驱动架构背后的技术是事件循环的建立。程序调用一个函数，它会一致阻塞直到收到事件。其核心思想是令程序在等待输入输出完成前保持忙碌状态，最基本的事件通常类似于“我有数据就绪可被读取”或者“我可以无阻塞地写入数据”

在Unix中，用于构建这种事件循环的标准函数是系统调用select(2)或者poll(2)。它们会对几个文件描述符进行监听，并在其中之一准备好读或写时做出响应

在Python中，这些系统调用通过select模块开放了出来。很容易使用它们构造一个事件驱动系统

下面使用select的例子进行展示

```
import select
import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# never block on read/write operations
server.setblocking(0)

# bind the socket to the port
server.bind('localhost', 10000)
server.listen(8)

while True:
	# select() return 3 arrays containing the object(sockets, files...)
	# that are ready to be read, written to or raised an error 
	inports, outputs, excepts = select.select([server], [], [server])
	if server in inputs:
		connection, client_address = server.accept()
		connection.send("hello!\n")
```

关于select调用详细讲解，还可以参见[《Windows I/O模型之一：Select模型》](http://www.cnblogs.com/Mr-Zhong/p/4160988.html)
