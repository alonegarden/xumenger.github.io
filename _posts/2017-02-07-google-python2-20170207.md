---
layout: post
title: Google Python开源项目编码规范
categories: 软件质量之开发规范 python之基础
tags: python2 python3 python Google 编码规范
---

参考自：[《Google Python Style Guide》](https://google.github.io/styleguide/pyguide.html)

对应的中文版参考：[《Python 风格指南》](http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/)、[《Python 编码规范(Google)》](http://www.runoob.com/w3cnote/google-python-styleguide.html)

另外推荐这篇小文：[《高质量的工程代码为什么难写》](http://hellojava.info/?p=508)

##对你的代码运行pylint

**定义：**pylint是一个在Python源代码中查找bug的工具，对于C和C++这样的语言，这些bug通常由编译器来捕获。由于Python的动态特性，有些警告可能不对，不过伪警告应该很少

**优点：**可以捕获容易忽略的错误，例如输入错误，使用未赋值的变量等

**缺点：**pylint不完美。要利用其优势，我们有时候需要：围绕着它来写代码；抑制其告警；改进它；或者忽略它

**结论：**确保对你的代码运行pylint，抑制不准确的警告，以便能够将其他警告暴露出来

可以通过设置一个行注释来抑制告警，例如：

```
dict = 'something awful'  # Bad Idea... pylint: disable=redefined-builtin
```

pylint警告是以一个数字编号（如C0112）和一个符号名（如empty-docstring）来标识的。在编写新代码或更新已有代码时对告警进行处理，推荐使用符号名来标识

如果警告的符号名不够见名知意，那么请对其增加一个详细解释

采用这样抑制方式的好处是我们可以轻松查找抑制并回顾它们

可以使用命令`pylint --list-msgs`来获取pylint告警列表。可以使用命令`pylint --help-msg=C6409`，以获取关于特定消息的更多信息

相比较于之前使用的`pylint: disable-msg`，推荐使用`pylint: disable`

要抑制“参数未使用”告警，可以使用"\_"作为参数标识符，或者在参数名前加"unused\_"。遇到不能改变参数名的情况，可以通过在函数开头“提到”它们来消除告警，例如：

```
def foo(a, unused_b, unused_c, d=None, e=None):
	_ = d, e
	return a
```

##导入：仅对包和模块使用导入

**定义：**导入是指模块间共享代码的重用机制

**优点：**命名空间管理约定十分简单。每个标识符的源都用一种一致的方式指示。x.Obj表示Obj对象定义在模块x中

**缺点：**模块仍可能冲突。有些模块名太长，不太方便

**结论：**

* 使用`import x`来导入包和模块
* 使用`from x import y`，其中x是包前缀，y是不带前缀的模块名
* 使用`from x import y as z`，如果两个要导入的模块都叫y，或者y太长

例如，模块"sound.effects.echo"可以用如下方式导入：

```
from sound.effects import echo
...
echo.EchoFilter(input, output, delay=0.7, atten=4)
```

导入时不要使用相对名称，即使模块在同一个包中，也要使用完整包名。这能帮助你避免无意间导入一个包两次

##包：使用模块的全路径名来导入每个模块

**优点：**避免模块名冲突，查找包更容易

**缺点：**部署代码变难，因为你必须复制包层次

**结论：**所有的新代码都应该用完整包名来导入每个模块

应该像下面这样导入：

```
# Reference in code with complete name.
import sound.effects.echo

# Reference in code with just module name (preferred)
from sound.effects import echo
```

##允许使用异常，但必须小心

**定义：**异常是一种跳出代码块的正常控制流来处理错误或者其他异常条件的方式

**优点：**正常操作代码的控制流不会和错误代码混在一起。当某种条件发生时，它也允许控制流跳过多个框架。例如，异步跳出N个嵌套的函数。而不必继续执行错误的代码

**缺点：**可能会导致让人困惑的控制流，调用库时容易错过错误情况

**结论：**异常必须遵守特点条件：

* 像这样触发