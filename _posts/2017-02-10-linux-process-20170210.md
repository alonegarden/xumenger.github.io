---
layout: post
title: Linux开发简单多进程应用
categories: c/c++之多进程 linux之多进程 windows之多进程 delphi之多进程
tags: c c++ linux windows 事件对象 多进程 进程 fork pipe
---

一个进程中的多个线程共享一个进程的堆等内存空间，所以实现数据交互是很方便的；但多进程架构中，要想实现多进程间的数据交互相对就困难很多！

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传递或交换信息。IPC常见的方式有：管道（无名管道、命名管道）、消息队列、信号量、共享内存、磁盘文件、Socket等，其中Socket网络方式可以实现不同主机上的多进程IPC

就以我目前工作中维护的软件项目为例，其是在Windows平台上的多进程/多线程程序，使用共享内存来传递数据，使用事件对象来实现跨进程的通知，其大概的架构逻辑是这样的：

* 主进程中负责交互的线程往共享内存1中写入请求数据，通过事件对象通知子进程，同时主进程负责交互的线程卡住等待
* 子进程负责交互的线程通过事件对象得知主进程往共享内存1写入数据，则开始运行去读取数据
* 然后去处理请求数据，处理完成后，将应答数据写入共享内存1，同样通过事件对象通知主进程，同时子进程负责交互的线程卡住等待
* 主进程负责交互的线程通过事件对象状态变化得知子进程处理完成并返回应答，则开始运行去读取应答
* 如此循环....
* 以上是主进程请求，子进程应答的情况；很简单的，根据对称性，再增加一个共享内存条、事件对象2可以实现子进程请求，主进程应答！

Windows平台与进程相关的API有：CreateProcess、OpenProcess……

##Linux使用管道开发多进程

下面使用fork()、pipe()实现一个简单的Linux平台下的多进程、多进程通信的程序

```
#include<stdio.h>
#include <unistd.h>

int main()
{
    int fd[2];    //两个文件描述符
    pid_t pid;
    char buff[20];

    //创建管道
    if(0 > pipe(fd)){
        printf("Create Pipe Error!\n");
    }

    //创建进程
    pid = fork();
    if(0 > pid){    //fork()返回值小于0，说明创建子进程失败
        printf("Fork Error!\n");
    }
    else if(0 < pid){  //fork()在主进程中返回新建的子进程的id
        //往管道的写端写入数据（发送给子进程）
        write(fd[1], "Hello My Son!\n", 14);
        
        sleep(1);

        //从管道的读端读取数据（获取子进程信息）
        read(fd[0], buff, 20);
        printf("%s", buff);
    }
    else if(0 == pid){ //fork()在子进程中返回0
        //从管道中读取数据（获取主进程信息）
        read(fd[0], buff, 20);
        printf("%s", buff);

        //往管道的写端写入数据（发送给主进程)
        write(fd[1], "Hello My Father!\n", 17);
    }

    return 0;
}
```

编译程序`gcc process.c -o process`，然后执行`./process`输入信息如下

![image](../media/image/2017-02-10/01.png)

