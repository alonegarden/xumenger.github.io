---
layout: post
title: WinDbg小试牛刀
categories: 深入学习之操作系统 深入学习之编译原理 深入学习之逆向工程
tags: debug 调试 Windows OllyDbg WinDbg Linux GDB 进程 Dump 转储文件 用户态 内核态 远程调试 破解 逆向工程 符号 JIT
---

去年5月份出差，在客户现场遇到一个诡异的问题：一个专门压缩日志的在压缩完成后调用SuspendThread方法却无法将其挂起，线程一直在疯狂运行，导致大量占用CPU资源，又因为该线程会发送消息给主线程，主线程将信息打印到界面，进而导致主线程过度繁忙地处理消息使得界面完全无法点击和拖动，差点引起生产问题（这可是我们的产品在客户那里第一次上线，第一天就没法进行股票交易可是大问题），幸好通过暂时更换一台机器的方式解决了这个问题

但更换机器只是暂时的解决方案，为什么在之前的机器上就是存在问题？为什么线程根本就停不下来？我使用普通的排查方法，比如注释代码、分析代码根本没有什么有效的进展

回到公司后请教了技术专家；另外请客户现场的同事配合原来的机器上复现问题，并且使用procdump获取该进程此时的内存转储文件，然后发回公司进行分析

不愧是技术专家，使用WinDbg，发现了这个进程加载了几个异常的DLL，查资料发现这几个DLL是与Windows兼容模式有关，然后在自己的机器上做一个简单的多线程程序，修改其【兼容Windows 98】，然后运行，确实调用SuspendThread会无效，线程无法正常被挂起，而且也发现这种修改了兼容性的情况并不需要更换新机器，在原有的机器上更换一下可执行文件的目录就可以。再让现场的同事帮确认，确实是因为程序以【兼容Windows 98】运行，在“有问题”的机器上更换新的目录页确实可以正常工作了

>上面是在把问题排查清楚后的复述，看起来思路很清楚，也没有什么难度，但当第一次遇到线程无法挂起的诡异现象，有没有任何有效信息，从0开始排查，可想而知其难度有多大：怎么去分析Dump文件？怎么发现这些异常的DLL有问题？如何进行合理的猜测，再针对这个猜测去试验和验证？怎么查以及去什么地方查关于这些异常DLL的资料？这些都需要长期的软件调试实践的积累（经验），以及对于计算机原理、操作系统原理等知识的深刻掌握（基础知识）

当然会吐槽是哪个二货把程序的兼容模式修改了。但也正是因为这个二货让我第一次感受到WinDbg的强大，正确的说是感受到技术专家能力之强，毕竟工具再强大自己不会用也是白搭。也就是在那个时候对软件调试产生了巨大的兴趣

##WinDbg和调试简介

[《使用WinDbg、Map文件、Dump文件定位Access Violation的代码行》](http://www.xumenger.com/windbg-map-access-violation-20160715/)中简单地提到WinDbg；[《汇编与逆向基础：使用IDA和OllyDbg分析C函数调用》](http://www.xumenger.com/c-assembly-ollydbg-ida-20161216/)中讲到了Windows平台上的另一个调试工具OllyDbg的使用，还算是比较深入的。学习软件调试的时候，在Windows平台可以OllyDbg和WinDbg配合着研究，另外也可以同时研究Linux平台的软件调试，[《初步了解如何用GDB分析Core文件》](http://www.xumenger.com/linux-c-cpp-gdb-coredump-20160908/)

接下来对WinDbg的应用、原理做一个简单的介绍，背后涉及到的调试原理、CPU、操作系统原理、编译原理、汇编等知识的体量之大，是不可能在短短的一篇文章中说清的

WinDbg可以启动一个新进程进行调试、可以Attach到一个正在运行的进程上进行调试、可以分析进程内存转储文件；可以在用户态进行调试，也可以在内核态进行调试；可以调试本机进程，也可以进行远程调试……

可以在用户生产环境设置JIT调试器为WinDbg，然后在程序崩溃时可以自动将WinDbg调试器Attach到崩溃进程上，然后在配合远程调试通过网络在自己的本机上进行调试，如此处理客户环境程序的崩溃问题难度将大大降低；再不济，可以使用procdump或者任务管理器，在程序崩溃时及时将程序Dump下来，然后使用WinDbg在本地分析Dump文件也是很好的调试崩溃问题、地址异常问题等的好方法。如此一来，面对蛋疼的崩溃问题、非法地址问题都不再像以前那样棘手了

一个成熟的计算机系统从硬件到软件都会有对调试有很好的支持：

* CPU的调试支持：INT1、INT3，调试寄存器、陷阱标志、中断异常和分支监视
* 操作系统的调试支持：调试事件的分发和管理，用户态调试子系统、内核调试引擎、调试API
* 编译器的调试支持：调试符号、运行期检查
* 调试器的调试功能，以及被调试软件的可调试性

调试能力需要依赖于以下的知识、技能：

* 比如Windows，要熟知各种重要的dll的作用，比如kernel32.dll、ntdll.dll等
* 熟知调试器的基础命令，然后更多的在实践中积累
* 熟悉各种调试器（WinDbg、OllyDbg、GDB等）的调试交互逻辑
* 了解调试的原理
* 熟悉栈回溯
* 熟悉汇编语言
* 熟悉进程的内存结构
* 熟悉CPU的工作原理：寄存器、汇编
* 熟悉对应的操作系统，比如Windows的消息机制、多线程等
* CPU、操作系统、编译原理等这些计算机基础知识当然是知道越多越好

>当然计算机组成原理、操作系统原理、编译原理相关的知识都是接下来需要恶补的

##使用WinDbg“扫雷”

这个例子是展示如何使用WinDbg调试、破解扫雷程序，也算是一个最简单的逆向工程的例子了，对应的扫雷程序点击[这里](../download/20170214/winmine.zip)下载

对应的操作系统是Windows7

打开WinDbg，选择符号文件设置

![image](../media/image/2017-02-14/01.png)

输入：`SRV*c:\symbol* http://msdl.microsoft.com/download/symbols`，然后点击OK即可。之前在[《WinDbg配置Symbol(符号)》](http://www.xumenger.com/windbg-symbol-20160521/)中的方法并不值得参考

![image](../media/image/2017-02-14/02.png)

然后使用WinDbg打开扫雷程序

![image](../media/image/2017-02-14/03.png)

![image](../media/image/2017-02-14/04.png)

然后弹出如下对话框，选择Yes、No都可以

![image](../media/image/2017-02-14/05.png)

打开后界面是如下的

![image](../media/image/2017-02-14/06.png)

使用WinDbg打开新的程序后，进程并不会直接运行，需要输入命令`g`将被调试程序运行起来，并且操作被调试的扫雷程序，将其修改为难度为99个雷的模式

![image](../media/image/2017-02-14/07.png)

然后点击下面红框中的按钮，让被调试程序暂停运行

![image](../media/image/2017-02-14/08.png)

如此才可以在命令框中输入命令进行调试

![image](../media/image/2017-02-14/09.png)

在有调试符号的情况下，输入`x winmine!*`即可输出被调试程序winmine.exe的所有符号信息

x命令显示所有上下文中匹配指定模板的符号，以及符号的地址。可用字符通配符

![image](../media/image/2017-02-14/10.png)

可以看到其中很多符号后面带有` = <no type information>`信息，因为我们没有私有符号，只有公开符号，所以不知道这些变量的类型是什么

在逆向分析时，合理的猜测是很强的能力，有一些常用的编程约定，比如全局变量一般以g\_开头命名，我们试着输出有没有以g开头的符号

![image](../media/image/2017-02-14/11.png)

看到输出的g开头的符号信息，其中`01005950 winmine!g_hReg`看起来像一个全局变量，`0100347c winmine!GameOver`看其来像是在扫雷结束后执行的函数

再试着输出以c开头的符号

![image](../media/image/2017-02-14/12.png)

函数名、变量名本身就包含着一些重要信息，所以完全可以根据变量名、函数名对其用处进行合理的猜测，然后后面正在调试器中试着通过修改变量名、修改函数指针的方式来进行验证

比如猜测`0100579c winmine!cSec`可能是记录时间的，`01005194 winmine!cBombLeft`是记录还有多少地雷的

>逆向工程就是如此的反复猜测、验证的过程，这个小程序的变量名、函数名还算是规范的，所以可以获取很多信息，假如是一个加了密的程序，逆向起来就不可能像是这么简单了

然后输入`dd winmine!cBombLeft`命令，来查看winmine!cBombLeft这个符号（可能是变量，可能是函数）在程序内存中的值

![image](../media/image/2017-02-14/13.png)

dd输出的是内存地址，以及地址中的内容信息，可以看到winmine!cBombLeft在内存中的值是16进制的63，也就是10进制的99，正好就是现在雷的个数

使用WinDbg可以进行进制的转换

![image](../media/image/2017-02-14/14.png)

然后尝试去修改内存中的winmine!cBombLeft的值，使用命令`ed winmine!cBombLeft 0`即可修改对应内存中的值

再去`dd winmine!cBombLeft`，可以看到内存中的值确实被修改为0了

![image](../media/image/2017-02-14/15.png)

上面`x winmine!g*`输出了GameOver，猜测应该是游戏结束时执行的函数，所以我们可以通过强行将程序指针指向GameOver函数来结束游戏

查看GameOver的地址是0100347c

![image](../media/image/2017-02-14/16.png)

使用命令`r eip=0100347c`来强制将函数指针eip寄存器指向GameOver的地址，这样接下来继续运行`g`被调试程序的时候，就会紧接着调用GameOver方法。补充：直接`r eip`是显示eip寄存器的值

不过现在的线程是1号线程

![image](../media/image/2017-02-14/17.png)

需要执行`~0s`命令切换到0号线程，因为从Windows7开始，窗口线程有一个特殊的激活过程，1号线程并不是窗口线程，0号才是

![image](../media/image/2017-02-14/18.png)

然后再执行`r eip=0100347c`，修改0号线程的函数指针

>注意，每个线程有自己独立的函数指针

![image](../media/image/2017-02-14/19.png)

然后输入命令`g`继续执行被调试程序，可以看到游戏结束，扫雷成功！！

![image](../media/image/2017-02-14/20.png)

##WinDbg命令总结

上面的调试过程中涉及到了一些简单的WinDbg命令，下面进行一个总结

* `x winmine!g*`：输出winmine模块中，g开头的符号名（变量、函数等）、首地址
* `dd winmine!cBombLeft`：输出winmine模块中cBombLeft的地址、内存内容信息
* `ed winmine!cBombLeft 0`：将winmine模块中的cBombLeft的值修改为0
* `r eip=0100347c`：将当前线程的函数指针寄存器指向内存0100347c，这样接下来当前线程就会被强制执行0100347c地址处的指令
* `g`：继续运行被调试程序

另外补充一下，WinDbg的调试命令可以分为3类，方便我们记忆WinDbg命令：

* 常规命令：命令一般比较短，比如dd、ed、lm、x。其应用较多，所以短命令输入更方便
* 元命令：命令前面有一个.，比如\.reboot、\.reload
* 扩展命令：命令前面有一个!，比如!process、!thread

关于Windows平台的调试，特地强调一点，假如当前程序的线程A遇到断点停止运行，那么当前程序的其他线程也都同时停止运行，同理要恢复运行则同时恢复运行；而Linux平台不同，其可以指定某个线程停止运行，其他线程继续运行
