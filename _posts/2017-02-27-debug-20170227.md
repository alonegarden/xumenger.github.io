---
layout: post
title: 软件驱魔方法论
categories: 深入学习之内存管理 软件质量之性能 深入学习之计算机组成原理
tags: debug 调试 CPU 内存 性能 OllyDbg WinDbg GDB PDB Windows Linux python UML 面向对象 类图 函数调用树 版本控制
---

在一个完整的软件工程流程中，开发只是很小的一部分，前期的需求调研、设计，后期的测试、维护等都占更大的比重

如何阅读遗留代码、如何排查问题、如何维护遗留代码、软件调试、如何优化代码（内存、CPU）、开发规范……

要知道为什么某些策略是有效的，需要花时间查看编译器在幕后都做了什么。要做到这一点，最好的办法是查看编译器生成的汇编代码。同样，构建系统软件要求你需要具备不同的能力，比如插入内联汇编代码，显式地操作内存，并生成一个原生可执行文件。只是恰巧，C++提供了这些功能。这毫不奇怪，然后，当前的绝大多数操作系统都是用C和C++组合实现的。当涉及处理中断及与硬件通信时，总是不可避免地有汇编代码参与其中。C和C++中的高级结构和汇编代码交融，使汇编级例程可以隐藏在系统深处

##如何有效阅读遗留代码

对于面向过程的编程语言编写的项目，比如C，阅读其源码时建议将函数调用树绘制出来，根据函数调用树了解每个函数在项目中所处的位置、调用关系，一个高质量的项目其函数调用树应该是清晰的有条理的；相对的，对于面向对象的编程语言，比如Delphi、C++、Python等，阅读其代码时建议将其类图等绘制出来根据类图了解各个类之间的关系，方便从全局层面把握项目代码，推荐小文[《类与类之间的几种关系》](http://www.cnblogs.com/liuling/archive/2013/05/03/classrelation.html)

同样的，如果有项目设计文档，那么对比项目设计文档来阅读源码也会事半功倍，需要小心文档的版本可能与代码的版本不对应！另外还有很多的项目其是多层架构的，那么每层之间都通过规范的接口来进行对接的，那么对着接口文档，了解有哪些接口、各个接口的每个字段具体有什么作用、值域是什么对于阅读接口上下层的代码很有用；数据表也是一种接口，是程序与数据库对接的规范，所以弄清楚数据表的各个字段含义、字段值域是极其必要的

##排查问题

对于当前排查的问题，对着最新版的代码可能发现代码没有问题啊，那就考虑当前运行的程序是不是并不是最新版的代码编译的，试着去对比前几个版本的代码，再去排查

在软件领域，问题可以分成以下几个层面：

* 当前业务程序本身的逻辑问题
* 当前业务程序依赖的底层问题：或者是第三方库，或者是操作系统

##软件调试

Windows平台的OllyDbg、WinDbg，Linux平台的GDB，Python的PDB等工具使得跟踪程序执行逻辑、排查疑难杂症有了很大的方便

调试器具有代码级别的调试能力，完全取决于程序的调试符号表。程序的调试表基本上是一个小型的自包含数据库，由一个变长的记录集组成。这些记录则由编译器在编译过程中通过将源代码翻译为目标代码所生成。所有目标代码文件最后被链接器合并，并且保存在可执行文件中

>对于不同的目标代码格式，调试符号表一般记录在两个地方：记录在目标代码本身之中、记录在单独的文件之中

调试符号文件可以将函数及变量与它们在内存中的地址映射起来。这是符号调试器相对于机器调试器最基本的一个优势。比如，源代码到内存的映射使符号调试器可以显示一个变量的值，因为变量的标识符与程序的数据段（或者为堆和栈）中的特定地址是相匹配的。不仅如此，符号表中还记录了数据类型信息，这样调试器就能知道正在检索的数据所对应的类型，并显示出来。这个映射关系也包含了源代码语句对应的指令在内存中的地址范围。当调试器跟踪源代码语句时，符号调试器会在程序的调试信息记录中帮你查找与源代码对应的指令在内存中的地址范围。然后开始执行对应范围的指令

存在很多不同的可执行文件格式，例如ELF、COFF、PE，每种格式都有自己保存调试符号信息的方式

##计算机资源

现在的PC动不动就是8G内存、16G内存，使得我们现在大多的程序开发人员不懂得节约内存、有效的利用内存

计算机程序需要处理两种基本的资源：处理器时间，即CPU周期；内存。高性能程序都谨慎地使用这些资源，换言之，高性能程序会尽可能小，尽可能快

在学习算法与数据结构课程的时候，一直在重点强调的两个词就是：时间复杂度、空间复杂度，其实就是在强调计算机的两种基本的资源

##内存优化

在你打算做优化之前，你应该：对代码做全面的测试和调试；对代码做性能剖析以识别瓶颈；使用更好的算法作为优化的替代品

如果你找准了目标却遇到了障碍，在准备做些可能会让你将来后悔的事情之前，请尝试使用更好的算法。不管再怎么优化使用冒泡排序的函数，它还是比使用快速排序算法实现要慢；如果二叉搜索树是不平衡的，那么就使用2-3树或红黑树；如果栈溢出，就通过引用而不是值传递参数。在你拿出危险的武器前，总是试图先从算法的角度寻找解决方案

要想对程序做内存优化，首先需要知道对于平台下进程的内存模型，了解代码段、数据段、栈、堆这些不同内存区域存放的是什么，以及它们的作用。相关文章[《Linux下32位进程内存模型》](http://www.xumenger.com/02-linux-process-memory-20170101/)、[《汇编与逆向基础：VC++6.0 调试模式下探究Win32进程堆内存模型》](http://www.xumenger.com/windows-vcpp-debug-20161203/)

代码段存储程序指令。优化策略有：同一个逻辑操作仅在一个地方陈述；使用函数替代基于宏的操作；定期从源代码树中修除僵尸代码

数据段存放全局变量。优化策略有：使用双重用途的数据结构；使用压缩算法压缩存储

栈段存放局部变量、函数参数。优化策略有：限制传递给函数的参数个数；把冗长的参数列表整合到一个专门结构中；按引用而不是值来传递参数；避免定义大的局部变量

堆段提供动态分配的存储空间。优化策略有：如果可能，使用suballocator（内存池）；允许延迟实例化；回收对象；定期检查内存黑洞和泄漏

##CPU优化

>优化程序对CPU的利用率，有一个最本质的方法，将代码翻译成汇编程序，通过汇编分析程序在运行时候的步骤、条件分支、循环分支等，查看是不是有一些无效的工作、冗余的逻辑等，然后对应在代码层面修改

有效地利用处理器时间——即是说，通过消除不必要的操作，使程序用最少的时间做最多的事情

可以使用特定技术，以最小化处理器执行每个操作所花费的时间。这些技术可能导致代码难以维护，并且占用更多内存。只有在彻底地调试过代码，通过性能剖析发现了瓶颈，并寻找到更好的算法之后，才作为最后的手段去使用它们

可以在以下几个领域来优化代码以有效的利用CPU时间：

函数调用。有节制地使用goto语句替代例程调用；把多个参数浓缩为一个结构体，并按引用传递它，以节约参数拷贝时间；避免使用参数个数可变的函数；有节制地使用系统调用，从用户态切换到内核态是很昂贵的；用迭代替换递归；使用返回值而不是异常

程序分支。使用查找表代替if-else和switch语句；switch语句通常比if-else语句更高效；在条件分支中把最常见的情况列在前面，这样就更容易击中条件

循环。把不变指令移出循环，这样指令就只执行一次，而不是在循环中反复被执行；尽量使用内联例程；使用原子变量取代数组引用；使用短路条件求值；利用循环展开和循环干涉；把if-else语句移到循环体外

内存管理。池化内存以更快地分配和回收；安装足够的内存，以便可以禁用分页到磁盘

输入/输出。在内存中缓存静态数据；按磁盘扇区大小的倍数缓冲数据。压缩数据以减少磁盘访问；使用手动磁盘布局以改善扇区邻近性

直线代码。预先计算；避免浮点值和整数之间的转换；使用强度折减技术；避开竞争激烈的同步代码

快速解决方案。购买更快的计算机；利用上下文相关的假设；利用编译器内置的优化策略；祈祷


