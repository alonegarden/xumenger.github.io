---
layout: post
title: 软件驱魔方法论
categories: 深入学习之内存管理 软件质量之性能 深入学习之计算机组成原理
tags: debug 调试 CPU 内存 性能 OllyDbg WinDbg GDB PDB Windows Linux python UML 面向对象 类图 函数调用树 版本控制
---

在一个完整的软件工程流程中，开发只是很小的一部分，前期的需求调研、设计，后期的测试、维护等都占更大的比重

如何阅读遗留代码、如何排查问题、如何维护遗留代码、软件调试、如何优化代码（内存、CPU）、开发规范等在软件的生命周期中是很重要但也很难、很繁琐冗杂的部分

>要知道为什么某些策略是有效的，需要花时间查看编译器在幕后都做了什么。要做到这一点，最好的办法是查看编译器生成的汇编代码。同样，构建系统软件要求你需要具备不同的能力，比如插入内联汇编代码，显式地操作内存，并生成一个原生可执行文件。只是恰巧，C++提供了这些功能。这毫不奇怪，然后，当前的绝大多数操作系统都是用C和C++组合实现的。当涉及处理中断及与硬件通信时，总是不可避免地有汇编代码参与其中。C和C++中的高级结构和汇编代码交融，使汇编级例程可以隐藏在系统深处

##如何有效阅读遗留代码

对于面向过程的编程语言，比如C，阅读其项目源码时建议将函数调用树绘制出来，根据函数调用树了解每个函数在项目中所处的位置、调用关系，一个高质量的项目其函数调用树应该是清晰的有条理的

相对的，对于面向对象的编程语言，比如Delphi、C++、Python等，阅读其项目源码时建议将其类图等绘制出来，根据类图了解各个类之间的关系，方便从全局层面把握项目代码，推荐小文[《类与类之间的几种关系》](http://www.cnblogs.com/liuling/archive/2013/05/03/classrelation.html)

除了代码本身之外，如果有对应的项目文档，那么对比项目文档来阅读源码也会事半功倍，需要小心文档的版本可能与代码的版本不对应！

另外还有很多的项目其是多层架构的，那么每层之间都通过规范的接口来进行对接的，那么对着接口文档，了解有哪些接口、各个接口的每个字段具体有什么作用、值域是什么对于阅读接口上下层的代码很有用；数据表也是一种接口，是程序与数据库对接的规范，所以弄清楚数据表的各个字段含义、字段值域是极其必要的

对应的，在软件生命周期中，将设计文档、接口文档、数据表说明文档、数据表关系图设计的尽可能清晰、准确，并且和代码在一起进行使用版本控制工具进行管理是极其有必要的

##问题排查策略

问题可以先分成以下几个层面：

* 当前程序本身的问题
* 当前业务程序依赖的底层问题：或者是第三方库，或者是操作系统，甚至是硬件的问题

对于第一种问题还可以继续划分：

* 业务性问题，比如处理业务逻辑不合理
* 技术性问题，比如卡死、CPU占用高、崩溃、内存泄漏

无论哪个问题，首先是确定这个问题对应的版本。因为往往对着最新版的代码可能发现代码逻辑是没有问题啊，那就考虑当前运行的程序是不是并不是最新版的代码编译的，试着去对比前几个版本的代码，再去排查

确定好版本之后应该尝试去复现问题，如果问题可以被复现，那么接下来的排查工作将会很好进行

比如对于第一类问题一般是逻辑层面的问题，排查起来也相对简单，只要自己对软件流程、业务逻辑熟悉即可。而且这类问题也往往都是容易复现的。问题复现之后，然后使用二分法先从整个程序入手，逐步细化定位到具体的模块，再往下定位到具体的代码上。如此应用二分法的方法可以用于排查绝大多数的软件问题

>最可怕的就是在最开始就因为需求没有调研清楚就匆忙的开始下面的设计、开发，那么一步错步步错，并且纠正这类错误会付出巨大的人力和经济成本。另外对于开发人员情绪的影响是一个难以量化但确实不得不深刻考虑的事情

另外还会有一些疑难杂症、难以复现的问题，比如程序卡死、程序崩溃、地址报错、栈溢出、线程同步、内存泄漏问题等也都有一些对应排查和解决的套路的。比如程序卡死，一般就是死循环、死锁、阻塞了，查看当时的CPU占用信息，使用WinDbg、GDB等工具介入，应该还是比较好排查的；程序崩溃问题比较难查，因为第一现场很难保存，最好设置操作系统在发现进程崩溃的时候自动进行内存转储，然后借助调试器去调试Core Dump文件以排查问题原因；当然传统的二分法也是值得使用的，比如在排查内存泄漏问题时，去定位到底是哪些代码导致的内存泄漏往往就会很有用……

>还是那句话：说着容易，做起来难。当错误隐藏在有几万、几十万、几百万行的代码当中，当最终的错误并不是某个具体的点而是多个原因共同作用导致的，当一个进程中的数十条线程随机获得时间片运行以至于在某个极偶然的点导致错误，如何灵活、熟练的应用以上的基本策略去最终定位到具体的那几行错误代码，其难度可想而知

##软件调试相关

Windows平台的OllyDbg、WinDbg，Linux平台的GDB，Python的PDB等工具使得跟踪程序执行逻辑、排查疑难杂症有了很大的方便

调试器具有代码级别的调试能力，完全取决于程序的调试符号表。程序的调试表基本上是一个小型的自包含数据库，由一个变长的记录集组成。这些记录则由编译器在编译过程中通过将源代码翻译为目标代码所生成。所有目标代码文件最后被链接器合并，并且保存在可执行文件中

>对于不同的目标代码格式，调试符号表一般记录在两个地方：记录在目标代码本身之中、记录在单独的文件之中

调试符号文件可以将函数及变量与它们在内存中的地址映射起来。这是符号调试器相对于机器调试器最基本的一个优势。比如，源代码到内存的映射使符号调试器可以显示一个变量的值，因为变量的标识符与程序的数据段（或者为堆和栈）中的特定地址是相匹配的。不仅如此，符号表中还记录了数据类型信息，这样调试器就能知道正在检索的数据所对应的类型，并显示出来。这个映射关系也包含了源代码语句对应的指令在内存中的地址范围。当调试器跟踪源代码语句时，符号调试器会在程序的调试信息记录中帮你查找与源代码对应的指令在内存中的地址范围。然后开始执行对应范围的指令

存在很多不同的可执行文件格式，例如ELF、COFF、PE，每种格式都有自己保存调试符号信息的方式

更多具体的调试技法就不在这里赘述了

##计算机资源

计算机程序需要处理两种基本的资源：处理器时间，即CPU周期；内存。高性能程序都谨慎地使用这些资源，换言之，高性能程序会尽可能小，尽可能快

在学习算法与数据结构课程的时候，一直在重点强调的两个词就是：时间复杂度、空间复杂度，其实就是在强调计算机的两种基本的资源

![image](../media/image/2017-02-27/01.jpeg)

>计算机核心问题就是时间和空间的问题。差的程序既浪费时间又浪费空间；合格的程序能够在时间和空间之间根据实际情况进行合理选择；绝好的程序应该既省时间又省空间，当然这是极难的，大多情景下省时间和省空间两者就是冲突的、不可兼得的

##内存优化

>现在的PC动不动就是8G内存、16G内存，使得我们现在大多的程序开发人员不懂得节约内存、有效的利用内存。甚至对于内存是什么、内存的原理都完全不清楚了

在你打算做优化之前，你应该：对代码做全面的测试和调试；对代码做性能剖析以识别瓶颈；使用更好的算法作为优化的替代品

如果你找准了目标却遇到了障碍，在准备做些可能会让你将来后悔的事情之前，请尝试使用更好的算法。不管再怎么优化使用冒泡排序的函数，它还是比使用快速排序算法实现要慢；如果二叉搜索树是不平衡的，那么就使用2-3树或红黑树；如果栈溢出，就通过引用而不是值传递参数。在你拿出危险的武器前，总是试图先从算法的角度寻找解决方案

要想对程序做内存优化，首先需要知道对于平台下进程的内存模型，了解代码段、数据段、栈、堆这些不同内存区域存放的是什么，以及它们的作用。相关文章[《Linux下32位进程内存模型》](http://www.xumenger.com/02-linux-process-memory-20170101/)、[《汇编与逆向基础：VC++6.0 调试模式下探究Win32进程堆内存模型》](http://www.xumenger.com/windows-vcpp-debug-20161203/)

**代码段**存储程序指令。优化策略有：同一个逻辑操作仅在一个地方陈述；使用函数替代基于宏的操作；定期从源代码树中修除僵尸代码

**数据段**存放全局变量。优化策略有：使用双重用途的数据结构；使用压缩算法压缩存储

**栈段**存放局部变量、函数参数。优化策略有：限制传递给函数的参数个数；把冗长的参数列表整合到一个专门结构中；按引用而不是值来传递参数；避免定义大的局部变量

**堆段**提供动态分配的存储空间。优化策略有：如果可能，使用suballocator（内存池）；允许延迟实例化；回收对象；定期检查内存黑洞和泄漏

##CPU优化

>优化程序对CPU的利用率，有一个最本质的方法，将代码翻译成汇编程序，通过汇编分析程序在运行时候的步骤、条件分支、循环分支等，查看是不是有一些无效的工作、冗余的逻辑等，然后对应在代码层面修改

有效地利用处理器时间——即是说，通过消除不必要的操作，使程序用最少的时间做最多的事情

可以使用特定技术，以最小化处理器执行每个操作所花费的时间。这些技术可能导致代码难以维护，并且占用更多内存。只有在彻底地调试过代码，通过性能剖析发现了瓶颈，并寻找到更好的算法之后，才作为最后的手段去使用它们

可以在以下几个领域来优化代码以有效的利用CPU时间：

**函数调用**。有节制地使用goto语句替代例程调用；把多个参数浓缩为一个结构体，并按引用传递它，以节约参数拷贝时间；避免使用参数个数可变的函数；有节制地使用系统调用，从用户态切换到内核态是很昂贵的；用迭代替换递归；使用返回值而不是异常

**程序分支**。使用查找表代替if-else和switch语句；switch语句通常比if-else语句更高效；在条件分支中把最常见的情况列在前面，这样就更容易击中条件

**循环**。把不变指令移出循环，这样指令就只执行一次，而不是在循环中反复被执行；尽量使用内联例程；使用原子变量取代数组引用；使用短路条件求值；利用循环展开和循环干涉；把if-else语句移到循环体外

**内存管理**。池化内存以更快地分配和回收；安装足够的内存，以便可以禁用分页到磁盘

**输入/输出**。在内存中缓存静态数据；按磁盘扇区大小的倍数缓冲数据。压缩数据以减少磁盘访问；使用手动磁盘布局以改善扇区邻近性

**直线代码**。预先计算；避免浮点值和整数之间的转换；使用强度折减技术；避开竞争激烈的同步代码

**快速解决方案**。购买更快的计算机；利用上下文相关的假设；利用编译器内置的优化策略；祈祷
