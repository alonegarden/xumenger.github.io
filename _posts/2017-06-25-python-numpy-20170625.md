---
layout: post
title: NumPy数组和矢量运算
categories: python之数据分析
tags: python numpy 数据分析 数组 矢量运算 线性代数 矩阵
---

## NumPy简介

NumPy(Numerical Python的简称)是高性能科学计算和数据分析的基础包，其部分功能如下：

* ndarray，一个具有矢量算术运算和复杂广播功能的快速且节省空间的多维数组
* 用于对整组数据进行快速运算的标准数学函数（无需编写循环）
* 用于读写磁盘数据的工具以及用于操作内存映射文件的工具
* 线性代数、随机数生成以及傅立叶变换功能
* 用于集成由C、C++、Fortran等语言编写的代码的工具

最后一点也是从生态系统角度来看最重要的一点。由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C/C++/Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口

NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具

对于大部分数据分析应用而言，主要关注的功能点在：

* 用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算
* 常用的数组算法，如排序、唯一化、集合运算等
* 高效的描述统计和数据聚合/摘要运算
* 用于异构数据集的合并/连接运算的数据对齐河关系型数据运算
* 将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）
* 数据的分组运算（聚合、转换、函数应用等）

虽然NumPy提供了这些功能的计算基础，但你可能还想将pandas作为数据分析工作的基础（尤其是对于结构化或表格化数据），因为它提供了能使大部分常见数据任务变得非常简洁的丰富高级接口。pandas还提供了一些NumPy所没有的更加领域特定的功能，如时间序列处理

## 多维数组

NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器，你可以利用这种数组对整块数据执行一些数学运算。下面这个简单的例子展示了ndarry的一些简单用法示例

```
In [1]: from numpy.random import randn    #导入numpy.random.randn

In [2]: import numpy as np                #导入numpy

In [3]: data = randn(2, 3)                #随机生成2*3的数组

In [4]: data                              #输出数据信息
Out[4]: 
array([[-0.88452944, -0.12395013, -0.33280688],
       [ 0.03746888, -0.48163027,  0.71136892]])

In [5]: data * 10                         #数组乘以10，其实就是对数组中的每个元素做乘以10操作
Out[5]: 
array([[-8.84529436, -1.2395013 , -3.32806883],
       [ 0.3746888 , -4.81630272,  7.11368919]])

In [6]: data + data                       #数组相加，其实就是数组中对应的元素做相加
Out[6]: 
array([[-1.76905887, -0.24790026, -0.66561377],
       [ 0.07493776, -0.96326054,  1.42273784]])

In [7]: data.shape                        #查看这个数组的维度大小
Out[7]: (2, 3)

In [8]: data.dtype                        #查看数组元素的数据类型
Out[8]: dtype('float64')
```

NumPy中创建数组的最简单方法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组

```
In [12]: data2 = [[1,2,3], [4,5,6]]

In [13]: arr2 = np.array(data2)           #转换得到一个二维数组

In [14]: arr2
Out[14]: 
array([[1, 2, 3],
       [4, 5, 6]])

In [15]: np.zeros((2,2))                  #创建指定形状的全0数组
Out[15]: 
array([[ 0.,  0.],
       [ 0.,  0.]])

In [16]: np.ones((2,3))                   #创建指定形状的全1数组
Out[16]: 
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.]])

In [17]: np.empty((2,3,2))                #创建指定形状的随机数组
Out[17]: 
array([[[  2.00000000e+000,   2.00000000e+000],
        [  2.23752437e-314,   2.23182464e-314],
        [  2.23121188e-314,   2.23751673e-314]],

       [[  1.64200515e-062,   0.00000000e+000],
        [  2.23738893e-314,  -5.71320723e-157],
        [  2.00000000e+000,   2.00389639e+000]]])

In [18]: np.arange(5)                     #arange是Python内置函数range的数组版
Out[18]: array([0, 1, 2, 3, 4])

```

dtype是NumPy强大和灵活的原因之一，多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、C++）”等工作变得简单

```
In [19]: typearr = np.array([1,2,3], dtype=np.float64)

In [20]: typearr
Out[20]: array([ 1.,  2.,  3.])

In [21]: typearr2 = typearr.astype(np.int64)

In [22]: typearr2
Out[22]: array([1, 2, 3])

In [23]: 
```

## 数组和标量之间的运算

>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。这通常被称为**矢量化**。大小相等的数组之间的任何算术运算都会将运算应用到元素级

```
In [3]: data = randn(2, 3)                #随机生成2*3的数组

In [4]: data                              #输出数据信息
Out[4]: 
array([[-0.88452944, -0.12395013, -0.33280688],
       [ 0.03746888, -0.48163027,  0.71136892]])

In [5]: data * 10                         #数组乘以10，其实就是对数组中的每个元素做乘以10操作
Out[5]: 
array([[-8.84529436, -1.2395013 , -3.32806883],
       [ 0.3746888 , -4.81630272,  7.11368919]])

In [6]: data + data                       #数组相加，其实就是数组中对应的元素做相加
Out[6]: 
array([[-1.76905887, -0.24790026, -0.66561377],
       [ 0.07493776, -0.96326054,  1.42273784]])
```

## 基本的索引和切片

NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式很多

```
In [24]: arr
Out[24]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [25]: arr[5]                  #索引到第5+1个元素
Out[25]: 5

In [26]: arr[5:8]                #切片：第5+1到第8个元素
Out[26]: array([5, 6, 7])

In [27]: arr[5:8] = 12           #因为数组切片是原始数组的视图，而不是复制，所以将改变原数组值

In [28]: arr
Out[28]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])

In [29]: arr_slice = arr[5:8]

In [30]: arr_slice[:] = 100

In [31]: arr
Out[31]: array([  0,   1,   2,   3,   4, 100, 100, 100,   8,   9])

In [32]: arr_copy = arr[5:8]

In [33]: arr_copy = arr[5:8].copy()      #需要显式调用copy方法才能进行复制

In [34]: arr_copy[:] = 0

In [35]: arr
Out[35]: array([  0,   1,   2,   3,   4, 100, 100, 100,   8,   9])

In [36]: 
```

>如上面展示的，NumPy数组和Python列表最重要的一点在于，数组切片是原始数组的视图，数据不会被复制，在视图上进行的任何修改都会直接反映到源数组上！

上面展示的是简单的一维数组的索引和切片操作，NumPy对于多维数组一样可以有强大的索引和切片处理能力

```
In [41]: arr2d = np.array([[1,2,3], [4,5,6], [7,8,9]])

In [42]: arr2d[2]             #索引二维数组的第2+1个元素（二维数组的元素是一维数组）
Out[42]: array([7, 8, 9])

In [43]: arr2d[0:1][0:1]
Out[43]: array([[1, 2, 3]])

In [44]: arr2d[0:1]
Out[44]: array([[1, 2, 3]])

In [45]: arr2d[0:1][1]         #二维数组的切片还是二维数组，[0:1]返回第一个一维数组组成的二维数组，所以索引第1+1个元素是会越界！
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-45-94b2938bdf41> in <module>()
----> 1 arr2d[0:1][1]

IndexError: index 1 is out of bounds for axis 0 with size 1

In [46]: arr2d[0:1][0]
Out[46]: array([1, 2, 3])

In [47]: arr2d[0, 0]
Out[47]: 1

In [48]: arr2d(0, 0)           #多维数组可以用[][]方式或[,]方式索引，但不能用(,)方式索引
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-48-15328b8da55e> in <module>()
----> 1 arr2d(0, 0)

TypeError: 'numpy.ndarray' object is not callable

In [49]: arr2d[0][0]
Out[49]: 1

In [50]: 
```

