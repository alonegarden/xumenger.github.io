---
layout: post
title: STL使用上的的更多细节
categories: C/C++之STL 
tags: c++ STL 算法 数据结构 字符串 引用计数 标准
---

>你对STL的使用越多，就越有必要区分你的C++编译器和你的STL库实现

## 线性容器的分类

数据结构中的容器可以按照如此方式分类：连续内存容器和基于节点的容器

连续内存容器（也称基于数组的容器）把它的元素存放在一块或多块（动态分配的）内存中，每块内存中存有多个元素。当有新元素插入或已有元素被删除时，同一内存块中的其他元素都要向前或向后移动，以便为新元素让出空间，或者填充被删除元素留下的空隙。这种移动影响到效率和异常安全性。在STL中标准的连续内存容器有vector、string、deque，非标准的rope也是一个连续内容容器

典型的连续内存容器就是C++中的原始数组

![image](../media/image/2017-09-16/01.png)

基于节点的容器在每一个（动态分配的）内存块中只存放一个元素。容器中元素的插入和删除只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入和删除操作时，元素的值不需要移动。表示链表的容器，如list是基于节点的，所有标准的关联容器，比如map也是基于节点的（通常使用平衡树实现）

典型的基于节点的容器就是下面这种链表实现

![image](../media/image/2017-09-16/02.png)

连续内存容器的特点是可以实现随机读取、修改，但新增和删除的时间复杂度就很高，因为需要内存块中的其他节点因为新节点插入或老节点删除而向前或向后移动；而基于节点容器则可以快速实现新增和删除，因为不需要移动其他节点，只需要调整前后节点的指针即可，但在搜索节点时就比较慢了，需要从第一个节点开始向后逐个和要搜索的对象进行对比

上面讲到连续内存容器和基于节点的容器在时间复杂度上各自的优势和缺陷。世上事情总是这样，甲、乙，往往只能是甲在A方面很极致，在B方面比较弱，而乙在A方面比较弱，却在B方面比较极致，最后为了平衡，总是将甲和乙做结合，得到一个各方面都比较适中的、中庸的解决方案。比如很多产品中将连续内存方案和基于节点的方案结合起来得到下面这样的数据结构

![image](../media/image/2017-09-16/03.png)

当然如果你的程序大部分操作是新增和删除操作，而没有搜索，那么就直接选择基于节点的数据结构。总之还是要根据自己的实际需求选择**最适合**的数据结构

## 关联容器

上面讲的是线性结构（序列容器），使用树形结构或其他结构（比如STL中map之类的关联容器）按照一定的规则组织数据的话，实现搜索会快很多，可是因为如此性能是建立在严格的结构规则上的，在新增或删除节点时，为了维持原有的结构规则，往往需要对其他节点做调整，这时就无法像线性结构一样有O(1)的时间复杂度了。比如大顶堆在新增和删除元素时，不能直接新增或删除，必须要继续按照大顶堆的结构规则做调整

下面对STL的关联容器简单介绍一下



## 引用计数和线程安全



## 字符串string

通过[《C++对象内存模型：C++的string和Delphi的string》](http://www.xumenger.com/cpp-delphi-string-20161116/)、[《标准C++类std::string的内存共享和Copy-On-Write技术》](http://blog.csdn.net/haoel/article/details/24058)等文章可以知道Delphi6中的string是使用引用计数实现的，而C++ STL中的string大部分实现方式也都是使用了引用计数机制的！

如果在你的程序中不介意引用计数机制，那么字符串类型直接选择使用std::string即可，但如果介意使用引用计数，那么就要避免使用std::string了，可以选择使用`vector<char>`来表示字符串

>string的引用计数并不是绝对的。这就涉及到软件工程中常说的接口和实现有关，不同的STL实现对外的接口是按照一个固定标准的，但其内部实现可能不同的STL有自己不同的选择，有的用引用计数，有的则不用。所以接口是标准，实现不是标准

## 容器中存储的是什么

>容器中保存了对象，但并不是你提供给容器的那些对象。当（通过如insert、push_back之类的操作）向容器中加入对象时，存入容器中的是你指定的对象的拷贝！拷贝对象是STL的工作方式

在往容器中放元素的时候，其实这些元素是保存在堆内存上的，比如vector

## 泛化思想

STL是以泛化原则为基础的：数组被泛化为“以其包含的对象的类型为参数”的容器；函数被泛化为“以其使用的迭代器的类型为参数”的算法；指针被泛化为“以其指向的对象的类型为参数”的迭代器