---
layout: post
title: Linux-C逆向工程基础：简单的栈溢出漏洞展示
categories: 深入学习之逆向工程 c/c++之指针与内存
tags: linux c c++ gcc 汇编 逆向工程 Linux-C逆向工程基础 栈溢出 漏洞
---

上面几篇文章简单的从汇编层面对C的执行逻辑、函数调用进行了分析，这篇文章来展示一个简单的栈溢出漏洞！

下面使用x86程序进行测试，x64的程序可以自己参考本文研究

先编写一个简单的程序

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

void func(int m, int n)
{
    int a = 23456;
    int b[2];
    printf("b[2] = %d\n", b[2]);    //发生栈溢出
    printf("b[-1] = %d\n", b[-1]);
}

int main(int argc, char **argv, char **env)
{
    func(2, 1);
    return 0;
}
```

当调用func函数时，保存起进程地址空间的栈时这样的

![](../media/image/2018-06-06/05-01.png)

正如我在[《Linux-C逆向工程基础：函数调用分析》](http://www.xumenger.com/linux-c-asm-3-20180606/)中简单分析的那样

* main在调用func之前，先要把参数压栈
    * 也就是为什么上图栈底前两个格子是局部变量 n=1, m=2
* (?)调用函数main的地址
* func函数的开始会`push ebp`，保存上个函数的ebp指针
    * 所以上图第四个格子是main的EBP指针
    * EBP就是保存当前函数的栈底地址
    * 因为函数调用的层次关系，当前函数的调用者的EBP就要保存在栈上
* 函数内部的局部变量也是压到栈上存储的
    * 所以func中的a、b[0]、b[1]都是存在在栈上的
    * 上图栈顶的三个格子

编译运行上面的程序，看到b[-1]索引到了a临时变量的位置，所以输出了a变量的值

![](../media/image/2018-06-06/05-02.png)

上图中第三格[调用函数main的地址]存储的是什么？上面初步总结的时候没有详细说明！

当调用完func函数的时候，程序是不是直接退出了？当然不是，程序会接着执行调用func函数的这个函数，也就是本例中的main函数

那么系统要运行这个函数首先得要知道这个函数的地址吧，所以当func执行完的时候，首先就可以在栈上获取main的地址，eip指针指向这个函数地址就可以继续执行main函数了

>注意：这里并不是main函数的起始地址，而是main上次执行到的那个地址，这样才能保证func执行完成后，继续从main函数上次执行到的地方继续执行，而不是从main函数开始的地方执行

而且main函数的EBP指针也都保存在栈上，都可以在func执行完后从栈上获取到！

>[《Linux-C逆向工程基础：函数调用分析》](http://www.xumenger.com/linux-c-asm-3-20180606/)没有讲解到栈上保存函数地址的问题，这里简单补充一下！

## 简单的栈溢出攻击

上面的例子，如果给b[-1]赋值为0，那么a还会是23456吗？

当然不是了！因为&b[-1]和&a是一样的地址，改变b[-1]对应的a也就改变了，那么如果我依次类推给b[-2],b[-3],b[-4]…依次赋个值呢

程序修改成这样

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

void func(int m, int n)
{
    int a = 23456;
    int b[2];
    printf("a = %d\n", a);
    b[-1] = 0;
    printf("a = %d\n", a);
}

int main(int argc, char **argv, char **env)
{
    func(2, 1);
    return 0;
}
```

现在修改了b[-1]的值，其实是间接修改了a的值

![](../media/image/2018-06-06/05-03.png)

编写测试程序如下：

```c
```

当我们调用func3而func3又调用func1时，栈结构应该是这样的

![](../media/image/2018-06-06/05-04.png)

怎么构造栈溢出漏洞，让func1执行完后不去接着执行func3而是去执行func2呢？

我们可以给func1的局部变量拷贝一个比它大的字符串

编译并运行上面的程序，果然程序走到了func2函数中去了

![](../media/image/2018-06-06/05-05.png)

>还有机器大小端的问题这里没有提及，请读者考虑大小端对栈溢出漏洞利用的影响

## 动态调试分析

下面使用GDB详细分析进程运行时的栈内存！


