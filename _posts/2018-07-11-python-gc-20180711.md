---
layout: post
title: Python垃圾回收机制
categories: 深入学习之编译原理
tags: Python GC 垃圾回收 Lua Ruby Java C C++ C# Lisp 智能指针 解释器 编译器 内存管理 引用计数 标记-清除 分代收集
---

>转载自[https://www.jianshu.com/p/1e375fb40506](https://www.jianshu.com/p/1e375fb40506)

现在的高级语言如Java、C#等，都采用了垃圾回收机制，而不再是C、C++里面用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为内存泄漏、悬空指针、重复释放等bug埋下隐患

对于一个字符串、列表、类甚至是数值都是对象，且定位简单易用的语言Python，自然不会让用户去处理如何分配回收内存的问题

>Python 里也同Java 一样采用了垃圾回收机制，不过不一样的是：Python 采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略

## 引用计数机制

Python 中每个东西都是对象，它们的核心就是一个结构体

```c
typedef struct _object{
    int ob_refcnt;
    struct _typeobject *ob_type;
}PyObject;
```

PyObject 是每个对象必有得内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用计数时，它的`ob_refcnt`就会增加，当引用它的对象被删除时，它的`ob_refcnt`就会减少

```c
#define Py_INCREF(op)   ((op)->ob_refcnt++)
#define Py_DECREF(op) \
    if(--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
```

当引用计数为0时，该对象生命就结束了

引用计数的优点是简单；实时性强，一旦没有引用，内存就直接释放。不像其他机制等到特定实际。实时性还带来一个好处，就是回收内存的时间分摊到了平时

但是引用计数也存在缺点：维护引用计数消耗资源、循环引用问题

```python
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```

list1 和list2 相互引用，如果不存在其他对象对它们的引用，list1 和list2 的引用计数也仍然为1，所占用的内存将永远无法回收，这将是致命的

C++中的智能指针shared\_ptr 的最大的陷阱也是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏，C++中是通过引入weak\_ptr 来解决

而Python中还将引入新的回收机制：标记-清除、分代收集

## 画说Ruby 与Python 垃圾回收

英文原文：[visualizing garbage collection in ruby and python](http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python)

中文：[画说 Ruby 与 Python 垃圾回收](https://ruby-china.org/topics/28127)

![](../media/image/2018-07-11/01.png)

如果将算法和业务逻辑比作应用程序的大脑，垃圾回收对应哪个器官呢？

GC系统锁承担的工作远比“垃圾回收”多得多。实际上，它们负责三个重要任务：

* 为新生成的对象分配内存
* 识别那些垃圾对象
* 从垃圾对象那里回收内存

如果将应用程序比作人的身体：所有你所写的那些优雅的代码、业务逻辑、算法，应该就是大脑。依次类推，垃圾回收机制应该是哪个身体器官呢？

我认为垃圾回收应该是应用程序那颗跃动的心。像心脏为其他器官提供血液和营养物那样，垃圾回收器为你的应用程序提供内存和对象。如果心脏停跳，过不了几分钟人就完了。如果垃圾回收器停止工作或运行迟缓,像动脉阻塞,你的应用程序效率也会下降，直至最终死掉

#### 一个简单的例子

运用示例一贯有助于理论的理解。下面是一个简单类，分别用Python 和Ruby 写成

```python
class Node:
    def __init__(self, val):
        self.value = val

print(Node(1))
print(Node(2))
```

```ruby
class Node
    def initialize(val)
        @value = val
    end
end

p Node.new(1)
p Node.new(2)
```

这两种语言在语法上如此相像，Ruby 和Python 在表达同一事物上真的只是略有不同。但是这两种语言的内部实现上是否也如此相似呢？

#### 可用列表

当我们执行上面的`Node.new(1)`的时候，Ruby 到底做了什么呢？Ruby 是如何管理我们创建的对象的呢？

出乎意料的是它做的非常少。实际上，早在代码开始执行，Ruby 就提前创建了成百上千个对象，并把它们串在链表上，名曰：可用列表。下图所示为可用列表的概念图

![](../media/image/2018-07-11/02.png)

想象一下每个白色方格上都标着一个“为使用预创建对象”。当我们调用`Node.new`，Ruby 只需取一个预创建对象给我们使用即可

![](../media/image/2018-07-11/03.png)

上图中左侧灰格表示我们代码中使用的当前对象，同时其他白格是未使用对象。（请注意：无疑我的示意图是对实际的简化。实际上，Ruby 会用另一个对象来装载字符串"ABC"，另一个对象装载Node 类定义，还有一个对象装载了代码中分析出的抽象语法树，等等）

如果我们再次调用 Node.new，Ruby将递给我们另一个对象

![](../media/image/2018-07-11/04.png)

这个简单的用链表来预分配对象的算法已经发明了超过50年了，而发明人是赫赫有名的计算机科学家John McCarthy，一开始是用Lisp实现的。Lisp不仅是最早的函数式编程语言，在计算机科学领域也有许多创举。其一就是利用垃圾回收机制自动化进行程序内存管理的概念

标准的Ruby，也就是总所周知的"Matz's Ruby Interpreter"(MRI)，所使用的GC 算法与McCarthy 在1960年的实现方式很类似。无论好坏，Ruby 的垃圾回收机制已经53岁高龄了。像Lisp 一样，Ruby 预先创建一些对象，然后在你分配新对象或者变量的时候供你使用

## Python 的对象分配

