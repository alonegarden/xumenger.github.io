---
layout: post
title: Python垃圾回收机制
categories: 深入学习之编译原理
tags: Python GC 垃圾回收 Lua Ruby Java C C++ C# 智能指针 解释器 编译器 内存管理 引用计数 标记-清除 分代收集
---

>转载自[https://www.jianshu.com/p/1e375fb40506](https://www.jianshu.com/p/1e375fb40506)

现在的高级语言如Java、C#等，都采用了垃圾回收机制，而不再是C、C++里面用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为内存泄漏、悬空指针、重复释放等bug埋下隐患

对于一个字符串、列表、类甚至是数值都是对象，且定位简单易用的语言Python，自然不会让用户去处理如何分配回收内存的问题

>Python 里也同Java 一样采用了垃圾回收机制，不过不一样的是：Python 采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略

## 引用计数机制

Python 中每个东西都是对象，它们的核心就是一个结构体

```c
typedef struct _object{
    int ob_refcnt;
    struct _typeobject *ob_type;
}PyObject;
```

PyObject 是每个对象必有得内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用计数时，它的`ob_refcnt`就会增加，当引用它的对象被删除时，它的`ob_refcnt`就会减少

```c
#define Py_INCREF(op)   ((op)->ob_refcnt++)
#define Py_DECREF(op) \
    if(--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
```

当引用计数为0时，该对象生命就结束了

引用计数的优点是简单；实时性强，一旦没有引用，内存就直接释放。不像其他机制等到特定实际。实时性还带来一个好处，就是回收内存的时间分摊到了平时

但是引用计数也存在缺点：维护引用计数消耗资源、循环引用问题

```python
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```

list1 和list2 相互引用，如果不存在其他对象对它们的引用，list1 和list2 的引用计数也仍然为1，所占用的内存将永远无法回收，这将是致命的

C++中的智能指针shared\_ptr 的最大的陷阱也是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏，C++中是通过引入weak\_ptr 来解决

而Python中还将引入新的回收机制：标记-清除、分代收集

