---
layout: post
title: Java杂谈
categories: 大型系统架构 java之多线程 java之面向对象
tags: Java 
---

Java杂谈，真的是“杂谈”！

前面的几篇文章讲到了Java的一些

## Java注解

在[《Spring Boot开发Web程序》](http://www.xumenger.com/java-springboot-20180322/)讲到Spring Boot 在做URL 路由的时候使用到了**注解**

```java
package com.example.demo;

import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    @RequestMapping("/")
    public String index() {
    	    return "This is Index Page";
    }
    
    @RequestMapping("/about")
    public String about() {
	    return "This is About Page";
    }
    
    @RequestMapping(value="/user/{name}", method= RequestMethod.GET)
    public String user(@PathVariable("name") String name) {
	    return "Hello " + name;
    }
}
```

在[《使用Flask进行简单Web开发》](http://www.xumenger.com/python2-flask-20170701/)中讲到Flask 在做URL 路由的时候是这样的

```python
# -*- coding: utf-8 -*-
from flask import Flask
app = Flask(__name__)

# 主页
@app.route('/')
def index():
    return '<h1>Hello World</h1>'

# 用户URL
@app.route('/user/<name>')
def user(name):
    return '<h1>Hello, %s</h1>' % name

if __name__ == '__main__':
    app.run(debug = True)
```

是不是很像？！那到底Java 的注解和Python 的装饰器

## Java类加载器和反射机制

## Java网络编程

BIO：是当发起I/O 的读或写操作时，均为阻塞方式，直到应用程序读到了流或者将流写入数据

NIO：基于事件驱动思想，常采用Reactor（反应器）模式。当发起I/O 请求时，应用程序是非阻塞的。当Socket 有流可读或写的时候，由操作系统通知应用程序，应用程序再将流读取到缓冲区或者写入系统

AIO：同样基于事件驱动的思想，通常采用Proactor（前摄器模式）实现。在进行I/O 操作时，直接调用API 的read 或write，这两种方法均为异步。对于读操作，操作系统将数据读到缓冲区，并通知应用程序，对于写操作，操作系统将write 方法传递的流写入并主动通知应用程序。它节省了NIO 中遍历事件通知队列的代价

