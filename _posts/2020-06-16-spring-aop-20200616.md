---
layout: post
title: Spring浅谈：AOP初始化过程
categories: java之web开发 java之web框架 
tags: java spring 切面 面向切面编程 AOP AspectJ 面向切面 编译 装饰器设计模式 声明式事务 IoC IoC容器 spring-context spring-aspects pom Maven 
---

上一章展示了AOP 的运行效果，大概展示了AOP 的功能是如何集成到Spring 框架中的，本文来看一下被切面的类在运行时刻的一些原理和现象！

上一章讲到，@EnableAspectJAutoProxy 为IoC 容器注入了AnnotationAwareAspectJAutoProxyCreator 这个Bean。再次将这个Bean 的继承关系列一下

```
AnnotationAwareAspectJAutoProxyCreator
    extends AspectJAwareAdvisorAutoProxyCreator
        extends AbstractAdvisorAutoProxyCreator
            extends AbstractAutoProxyCreator
                extends ProxyProcessorSupport
                implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware
```

前面几篇讲道理PostProcessor、Aware，这里重点看一下AbstractAutoProxyCreator 实现这两个接口的方法

实现Aware的接口是AbstractAutoProxyCreator.setBeanFactory()，实现为当前的类注入BeanFactory

>[Spring浅谈：Aware接口相关](http://www.xumenger.com/spring-bean-factory-aware-20200604/)

```java
@Override
public void setBeanFactory(BeanFactory beanFactory) {
    this.beanFactory = beanFactory;
}
```

再看实现SmartInstantiationAwareBeanPostProcessor 的接口，方便拦截Bean 的创建过程，实现在各个Bean 的初始化前后对其做一些定制化的加工

>[Spring浅谈：后置处理器PostProcessor](http://www.xumenger.com/spring-bean-post-processor-20200605/)

```java
@Override
public Object postProcessBeforeInstantiation(Class<？> beanClass, String beanName) throws BeansException {
    Object cacheKey = getCacheKey(beanClass, beanName);

    if (beanName == null || !this.targetSourcedBeans.contains(beanName)) {
        if (this.advisedBeans.containsKey(cacheKey)) {
            return null;
        }
        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return null;
        }
    }

    // Create proxy here if we have a custom TargetSource.
    // Suppresses unnecessary default instantiation of the target bean:
    // The TargetSource will handle target instances in a custom fashion.
    if (beanName != null) {
        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
        if (targetSource != null) {
            this.targetSourcedBeans.add(beanName);
            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
            this.proxyTypes.put(cacheKey, proxy.getClass());
            return proxy;
        }
    }

    return null;
}

@Override
public boolean postProcessAfterInstantiation(Object bean, String beanName) {
    return true;
}

@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) {
    return bean;
}

/**
 * Create a proxy with the configured interceptors if the bean is
 * identified as one to proxy by the subclass.
 * @see #getAdvicesAndAdvisorsForBean
 */
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (!this.earlyProxyReferences.contains(cacheKey)) {
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
```

## 更进一步的看一下这个继承树

![](../media/image/2020-06-16/01.png)

```
AnnotationAwareAspectJAutoProxyCreator
    extends AspectJAwareAdvisorAutoProxyCreator
        extends AbstractAdvisorAutoProxyCreator
            extends AbstractAutoProxyCreator
                extends ProxyProcessorSupport
                implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware
```

从父类开始往上看，每个类分别实现了哪些功能，结合Aware、PostProcessor 的工作原理弄清楚这些类的执行时机和调用关系

* AbstractAutoProxyCreator 实现了这些方法
    * BeanFactoryAware.setBeanFactory()
    * SmartInstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()
    * SmartInstantiationAwareBeanPostProcessor.postProcessAfterInitialization()
* AbstractAdvisorAutoProxyCreator 重写了这些方法
    * BeanFactoryAware.setBeanFactory() 内部调用了initBeanFactory()
* AspectJAwareAdvisorAutoProxyCreator
* AnnotationAwareAspectJAutoProxyCreator
    * 实现了initBeanFactory() 方法
    * 上面说到是在AbstractAdvisorAutoProxyCreator.setBeanFactory() 中调用的

经过上面的梳理，大概可以弄清楚从父类到子类分别实现了哪些接口，分别实现了哪些方法，对应的调用关系也差不多清楚了

>[Spring浅谈：Aware接口相关](http://www.xumenger.com/spring-bean-factory-aware-20200604/)

>[Spring浅谈：后置处理器PostProcessor](http://www.xumenger.com/spring-bean-post-processor-20200605/)

上面列过了AbstractAutoProxyCreator 这个类实现了Aware、PostProcessor 的接口的代码，下面看看另外的一些

AbstractAdvisorAutoProxyCreator 重写的setBeanFactory()

```java
@Override
public void setBeanFactory(BeanFactory beanFactory) {
    super.setBeanFactory(beanFactory);
    if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {
        throw new IllegalArgumentException(
                "AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: " + beanFactory);
    }
    initBeanFactory((ConfigurableListableBeanFactory) beanFactory);
}
```

AnnotationAwareAspectJAutoProxyCreator 实现的initBeanFactory() 方法

```java
@Override
protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    super.initBeanFactory(beanFactory);
    if (this.aspectJAdvisorFactory == null) {
        this.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory);
    }
    this.aspectJAdvisorsBuilder =
            new BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory);
}
```