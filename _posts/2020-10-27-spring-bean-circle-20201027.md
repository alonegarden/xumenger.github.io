---
layout: post
title: Spring 构造器循环依赖：Bean 的加载
categories: java之web开发 java之web框架 Spring之IoC
tags: java bean IoC 循环依赖 Spring 容器 constructor-arg 设计模式 模板模式 BeanDefinition
---

>参考《Spring技术内幕》、《Spring源码深度解析》

>本文涉及到的代码，不要在看文章的时候仅看列出来的这些框架的代码，跟着思路自己去Eclipse 中跟一下代码，这样才有效！

在[上一篇](http://www.xumenger.com/spring-bean-circle-20201026/)中讲到了Spring 容器启动过程中加载配置文件，解析得到BeanDefinition 的过程

>Spring初始化的过程中，首先解析XML配置文件，将一个个`<bean>` 转换为BeanDefinition

>Spring 通过BeanDefinition 将配置文件中的`<bean>` 配置内容转换为容器的内部表示，并将这些BeanDefinition 注册到BeanDefinitionRegistry 中

>Spring 容器的BeanDefinitionRegistry 就像是Spring 配置信息的内存数据库，主要以map 的形式存储。后续操作直接从BeanDefinitionRegistry 中读取配置信息

>但还没有讲到Bean 的加载（初始化）过程，所以还是解释不了Spring 是如何处理循环依赖的

在上一篇中的案例中，复现了构造器循环依赖的报错情况，当时报错时对应的调用栈是这样的

```
Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'ClassA' defined in class path resource [beans07.xml]: Cannot resolve reference to bean 'ClassB' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'ClassB' defined in class path resource [beans07.xml]: Cannot resolve reference to bean 'ClassA' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'ClassA': Requested bean is currently in creation: Is there an unresolvable circular reference?
    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:314)
    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110)
    at org.springframework.beans.factory.support.ConstructorResolver.resolveConstructorArguments(ConstructorResolver.java:662)
    at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:188)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1340)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1186)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515)
    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:860)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)
    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:144)
    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:85)
    at com.xum.demo07.Test.main(Test.java:9
```

现在再看这个调用栈可以大概分析出就是在加载Bean 时处理构造参数（resolveConstructorArguments()）导致的报错，这篇文章针对这个点就进一步进行研究

## IoC 容器的依赖注入

上面一章讲到了解析`<bean>` 得到BeanDefinition 并注册到容器的过程，但这个时候并没有生成实际的Bean，也没有对Bean 依赖关系进行注入

依赖注入的过程是首次调用getBean() 的时候触发的，当然在ApplicationContext(AbstractApplicationContext) 的refresh() 方法中，有调用finishBeanFactoryInitialization(beanFactory) 方法，这个方法就是在初始化的过程中对于non-lazy-init 的Bean 通过调用getBean() 方法实现容器初始化阶段的依赖注入

```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // Initialize conversion service for this context.
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    // Stop using the temporary ClassLoader for type matching.
    beanFactory.setTempClassLoader(null);

    // Allow for caching all bean definition metadata, not expecting further changes.
    beanFactory.freezeConfiguration();

    // Instantiate all remaining (non-lazy-init) singletons.
    beanFactory.preInstantiateSingletons();
}
```

具体在DefaultListableBeanFactory 的preInstantiateSingletons() 方法中

```java
@Override
public void preInstantiateSingletons() throws BeansException {
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Pre-instantiating singletons in " + this);
    }
    List<String> beanNames;
    synchronized (this.beanDefinitionMap) {
        // Iterate over a copy to allow for init methods which in turn register new bean definitions.
        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
        beanNames = new ArrayList<String>(this.beanDefinitionNames);
    }
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            if (isFactoryBean(beanName)) {
                final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);
                boolean isEagerInit;
                if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                    isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
                        @Override
                        public Boolean run() {
                            return ((SmartFactoryBean<?>) factory).isEagerInit();
                        }
                    }, getAccessControlContext());
                }
                else {
                    isEagerInit = (factory instanceof SmartFactoryBean &&
                            ((SmartFactoryBean<?>) factory).isEagerInit());
                }
                if (isEagerInit) {
                    getBean(beanName);
                }
            }
            else {
                getBean(beanName);
            }
        }
    }
}
```

## setter 循环依赖

上文也提到了，在Spring 中的循环依赖除了构造器循环依赖，还有setter 循环依赖！

