---
layout: post
title: Java NIO 非阻塞网络编程
categories: java之网络编程
tags: java NIO 网络编程 TCP 阻塞 非阻塞 telnet 事件驱动编程 Buffer 缓存 缓冲区
---

## Buffer 解释

在Java NIO 中，除了Channel、Selecor 之外，还有一个很重要的类，就是Buffer，前两个在后面的代码中比较好理解，所以先重点把Buffer 讲一下！

![](../media/image/2020-11-06/01.png)

* 容量：表示缓冲区可以保存多少数据
* 极限：表示缓冲区的当前终点
	* 不能对缓冲区超出极限的区域进行读写操作
	* 极限是可以修改的，这有利于缓冲区的重用
	* 比如假定缓冲区容量是100，已经填满了数据
	* 接着程序再重用缓冲区时，仅仅将10 个新的数据写入缓冲区中从位置0 到10 的区域
	* 这是可以把极限设置为10
	* 这样就不能读取位置从11 到99 的原来的数据了！！！
* 位置：表示缓冲区中写一个读写单元的位置
	* 每次读写缓冲区的数据时，该值都会变化，为下一次读写数据做准备

clear()。把极限设置为容量，把位置设置为0

flip()。将极限设置为位置，把位置设置为0

rewind()。不改变极限，把位置设置为0

remaining()。返回缓冲区的剩余容量。等于 极限 - 位置

compact()。删除缓冲区中从0 到当前位置position 的内容，然后把当前位置position 到极限limit 的内容拷贝到0 到 limit-position 的区域内，position 与limit 的值对应也变化

![](../media/image/2020-11-06/02.png)

## 实现一个非阻塞的服务端

```java
package com.xum.demo09.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;

public class SelectorServer {

    private Selector selector = null;
    private ServerSocketChannel serverSocketChannel = null;
    
    private Charset charset = Charset.forName("GBK");
    
    
    /**
     * 在构造方法中绑定端口
     * 
     * @throws IOException
     */
    public SelectorServer(int port) throws IOException
    {    
        selector = Selector.open();
        
        serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().setReuseAddress(true);
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.socket().bind(new InetSocketAddress(port));
        
        System.out.println("服务器启动...");
    }
    
    
    /**
     * 启动服务开始处理客户端连接、请求
     * @throws IOException 
     */
    public void service() throws IOException 
    {
        // 为服务端socketchannel 注册监控ACCEPT 事件，当有客户端连接时，该事件触发
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        /**
         * select() 方法阻塞执行，以下情况会导致其从阻塞中唤醒
         * 至少有一个SelectionKey 相关事件发生
         * 其他线程调用了Selector 的wakeup() 方法，导致执行select() 方法的线程立即从select() 中返回
         * 当前执行select() 的线程被其他线程中断
         */
        while (selector.select() > 0) {
            Set<SelectionKey> readyKeys = selector.selectedKeys();
            Iterator<SelectionKey> it = readyKeys.iterator();
            while (it.hasNext()) {
                SelectionKey key = null;
                try {
                    key = (SelectionKey)it.next();
                    it.remove();
                    
                    if (key.isAcceptable()) {
                        ServerSocketChannel ssc = (ServerSocketChannel)key.channel();
                        SocketChannel socketChannel = (SocketChannel)ssc.accept();
                        System.out.println("接收到新连接，客户端地址" 
                                          + socketChannel.socket().getInetAddress() + ":"
                                          + socketChannel.socket().getPort());
                        
                        // 新接收到的客户端连接，为其注册读、写事件，也使用Selector 监听
                        socketChannel.configureBlocking(false);
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE, buffer);
                    }

                    if (key.isWritable()) {
                        send(key);
                    }
                    
                    if (key.isReadable()) {
                        receive(key);
                    }
                    
                } catch (IOException ex) {
                    ex.printStackTrace();
                    
                    try {
                        if (null != key) {
                            key.cancel();
                            key.channel().close();
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    
    /**
     * 处理写事件

     * @throws IOException 
     */
    private void send(SelectionKey key) throws IOException 
    {
        ByteBuffer buffer = (ByteBuffer)key.attachment();
        SocketChannel socketChannel = (SocketChannel)key.channel();
        buffer.flip();
        
        String data = decode(buffer);
        if (data.indexOf("\r\n") == -1) 
            return;
        String outputData = data.substring(0, data.indexOf("\n") + 1);
        System.out.println(outputData);
        
        ByteBuffer outputBuffer = encode("echo: " + outputData);
        while (outputBuffer.hasRemaining()) 
            socketChannel.write(outputBuffer);
        
        ByteBuffer temp = encode(outputData);
        buffer.position(temp.limit());
        buffer.compact();   // 删除已经处理的字符串
        
        if (outputData.equals("bye\r\n")) {
            key.channel();
            socketChannel.close();
            System.out.println("关闭与客户端的连接");
        }
    }
    
    /**
     * 处理读事件

     * @throws IOException 
     */
    private void receive(SelectionKey key) throws IOException 
    {
        ByteBuffer buffer = (ByteBuffer)key.attachment();
        
        SocketChannel socketChannel = (SocketChannel)key.channel();
        ByteBuffer readBuffer = ByteBuffer.allocate(32);

        // 这里有一个bug，应该判断一下read() 的返回值，因为非阻塞，所以返回值可能小于指定的32
        // 另外还需要判断返回值是否为-1，如果是-1，表示客户端关闭了连接，服务端应该对应做相应处理
        socketChannel.read(readBuffer);
        readBuffer.flip();
        
        buffer.limit(buffer.capacity());
        buffer.put(readBuffer);    // 将读到的数据放到buffer 中
    }
    
    /**
     * 解码
     * 
     * @param buffer
     * @return
     */
    private String decode(ByteBuffer buffer) 
    {
        CharBuffer charBuffer = charset.decode(buffer);
        return charBuffer.toString();
    }
    
    /**
     * 编码
     * 
     * @param str
     * @return
     */
    private ByteBuffer encode(String str) 
    {
        return charset.encode(str);
    }
    
    
    /**
     * 启动服务器
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException 
    {
        SelectorServer server = new SelectorServer(10003);
        server.service();
    }
}
```

启动服务端后，开启一个终端，telnet 连接上去，其效果是这样的

![](../media/image/2020-11-06/03.png)
