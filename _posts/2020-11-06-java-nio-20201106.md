---
layout: post
title: Java NIO 非阻塞网络编程
categories: java之网络编程
tags: java NIO 网络编程 TCP 阻塞 非阻塞 telnet 事件驱动编程 
---


## 实现一个非阻塞的服务端

```java
package com.xum.demo09.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;

public class SelectorServer {

    private Selector selector = null;
    private ServerSocketChannel serverSocketChannel = null;
    
    private Charset charset = Charset.forName("GBK");
    
    
    /**
     * 在构造方法中绑定端口
     * 
     * @throws IOException
     */
    public SelectorServer(int port) throws IOException
    {    
        selector = Selector.open();
        
        serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().setReuseAddress(true);
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.socket().bind(new InetSocketAddress(port));
        
        System.out.println("服务器启动...");
    }
    
    
    /**
     * 启动服务开始处理客户端连接、请求
     * @throws IOException 
     */
    public void service() throws IOException 
    {
        // 为服务端socketchannel 注册监控ACCEPT 事件，当有客户端连接时，该事件触发
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        /**
         * select() 方法阻塞执行，以下情况会导致其从阻塞中唤醒
         * 至少有一个SelectionKey 相关事件发生
         * 其他线程调用了Selector 的wakeup() 方法，导致执行select() 方法的线程立即从select() 中返回
         * 当前执行select() 的线程被其他线程中断
         */
        while (selector.select() > 0) {
            Set<SelectionKey> readyKeys = selector.selectedKeys();
            Iterator<SelectionKey> it = readyKeys.iterator();
            while (it.hasNext()) {
                SelectionKey key = null;
                try {
                    key = (SelectionKey)it.next();
                    it.remove();
                    
                    if (key.isAcceptable()) {
                        ServerSocketChannel ssc = (ServerSocketChannel)key.channel();
                        SocketChannel socketChannel = (SocketChannel)ssc.accept();
                        System.out.println("接收到新连接，客户端地址" 
                                          + socketChannel.socket().getInetAddress() + ":"
                                          + socketChannel.socket().getPort());
                        
                        // 新接收到的客户端连接，为其注册读、写事件，也使用Selector 监听
                        socketChannel.configureBlocking(false);
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE, buffer);
                    }

                    if (key.isWritable()) {
                        send(key);
                    }
                    
                    if (key.isReadable()) {
                        receive(key);
                    }
                    
                } catch (IOException ex) {
                    ex.printStackTrace();
                    
                    try {
                        if (null != key) {
                            key.cancel();
                            key.channel().close();
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    
    /**
     * 处理写事件
     * @throws IOException 
     */
    private void send(SelectionKey key) throws IOException 
    {
        ByteBuffer buffer = (ByteBuffer)key.attachment();
        SocketChannel socketChannel = (SocketChannel)key.channel();
        buffer.flip();
        
        String data = decode(buffer);
        if (data.indexOf("\r\n") == -1) 
            return;
        String outputData = data.substring(0, data.indexOf("\n") + 1);
        System.out.println(outputData);
        
        ByteBuffer outputBuffer = encode("echo: " + outputData);
        while (outputBuffer.hasRemaining()) 
            socketChannel.write(outputBuffer);
        
        ByteBuffer temp = encode(outputData);
        buffer.position(temp.limit());
        buffer.compact();   // 删除已经处理的字符串
        
        if (outputData.equals("bye\r\n")) {
            key.channel();
            socketChannel.close();
            System.out.println("关闭与客户端的连接");
        }
    }
    
    /**
     * 处理读事件
     * @throws IOException 
     */
    private void receive(SelectionKey key) throws IOException 
    {
        ByteBuffer buffer = (ByteBuffer)key.attachment();
        
        SocketChannel socketChannel = (SocketChannel)key.channel();
        ByteBuffer readBuffer = ByteBuffer.allocate(32);
        socketChannel.read(readBuffer);
        readBuffer.flip();
        
        buffer.limit(buffer.capacity());
        buffer.put(readBuffer);    // 将读到的数据放到buffer 中
    }
    
    /**
     * 解码
     * 
     * @param buffer
     * @return
     */
    private String decode(ByteBuffer buffer) 
    {
        CharBuffer charBuffer = charset.decode(buffer);
        return charBuffer.toString();
    }
    
    /**
     * 编码
     * 
     * @param str
     * @return
     */
    private ByteBuffer encode(String str) 
    {
        return charset.encode(str);
    }
    
    
    /**
     * 启动服务器
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException 
    {
        SelectorServer server = new SelectorServer(10003);
        server.service();
    }
}
```

启动服务端后，开启一个终端，telnet 连接上去，其效果是这样的

![](../media/image/2020-11-06/01.png)
